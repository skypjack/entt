<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: Crash Course: graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EnTT<span id="projectnumber">&#160;3.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Crash Course: graph </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md118"></a>
Introduction</h1>
<p ><code>EnTT</code> doesn't aim to offer everything one needs to work with graphs. Therefore, anyone looking for this in the <em>graph</em> submodule will be disappointed.<br  />
 Quite the opposite is true. This submodule is minimal and contains only the data structures and algorithms strictly necessary for the development of some tools such as the <em>flow builder</em>.</p>
<h1><a class="anchor" id="autotoc_md119"></a>
Data structures</h1>
<p >As anticipated in the introduction, the aim isn't to offer all possible data structures suitable for representing and working with graphs. Many will likely be added or refined over time, however I want to discourage anyone expecting tight scheduling on the subject.<br  />
 The data structures presented in this section are mainly useful for the development and support of some tools which are also part of the same submodule.</p>
<h2><a class="anchor" id="autotoc_md120"></a>
Adjacency matrix</h2>
<p >The adjacency matrix is designed to represent either a directed or an undirected graph:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix&lt;entt::directed_tag&gt;</a> adjacency_matrix{};</div>
<div class="ttc" id="aclassentt_1_1adjacency__matrix_html"><div class="ttname"><a href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix</a></div><div class="ttdoc">Basic implementation of a directed adjacency matrix.</div><div class="ttdef"><b>Definition:</b> <a href="adjacency__matrix_8hpp_source.html#l00102">adjacency_matrix.hpp:102</a></div></div>
</div><!-- fragment --><p >The <code>directed_tag</code> type <em>creates</em> the graph as directed. There is also an <code>undirected_tag</code> counterpart which creates it as undirected.<br  />
 The interface deviates slightly from the typical double indexing of C and offers an API that is perhaps more familiar to a C++ programmer. Therefore, the access and modification of an element will take place via the <code>contains</code>, <code>insert</code> and <code>erase</code> functions rather than a double call to an <code>operator[]</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(adjacency_matrix.contains(0u, 1u)) {</div>
<div class="line">    adjacency_matrix.erase(0u, 1u);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    adjacency_matrix.insert(0u, 1u);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Both <code>insert</code> and<code>erase</code> are idempotent functions which have no effect if the element already exists or has already been deleted.<br  />
 The first one returns an <code>std::pair</code> containing the iterator to the element and a boolean value indicating whether the element has been inserted or was already present. The second one instead returns the number of deleted elements (0 or 1).</p>
<p >An adjacency matrix must be initialized with the number of elements (vertices) when constructing it but can also be resized later using the <code>resize</code> function:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix&lt;entt::directed_tag&gt;</a> adjacency_matrix{3u};</div>
</div><!-- fragment --><p >To visit all vertices, the class offers a function named <code>vertices</code> that returns an iterable object suitable for the purpose:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;vertex: adjacency_matrix.vertices()) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Note that the same result can be obtained with the following snippet, since the vertices are unsigned integral values:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> last = adjacency_matrix.size(), pos = {}; pos &lt; last; ++pos) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >As for visiting the edges, a few functions are available.<br  />
 When the purpose is to visit all the edges of a given adjacency matrix, the <code>edges</code> function returns an iterable object that can be used to get them as pairs of vertices:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [lhs, rhs]: adjacency_matrix.edges()) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >On the other hand, if the goal is to visit all the in- or out-edges of a given vertex, the <code>in_edges</code> and <code>out_edges</code> functions are meant for that:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> [lhs, rhs]: adjacency_matrix.out_edges(3u)) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >As might be expected, these functions expect the vertex to visit (that is, to return the in- or out-edges for) as an argument.<br  />
 Finally, the adjacency matrix is an allocator-aware container and offers most of the functionality one would expect from this type of containers, such as <code>clear</code> or 'get_allocator` and so on.</p>
<h2><a class="anchor" id="autotoc_md121"></a>
Graphviz dot language</h2>
<p >As it's one of the most popular formats, the library offers minimal support for converting a graph to a Graphviz dot snippet.<br  />
 The simplest way is to pass both an output stream and a graph to the <code>dot</code> function:</p>
<div class="fragment"><div class="line">std::ostringstream output{};</div>
<div class="line"><a class="code hl_function" href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">entt::dot</a>(output, adjacency_matrix);</div>
<div class="ttc" id="anamespaceentt_html_a8eb14d05375b98c803a4f335b9db15e4"><div class="ttname"><a href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">entt::dot</a></div><div class="ttdeci">void dot(std::ostream &amp;out, const Graph &amp;graph, Writer writer)</div><div class="ttdoc">Outputs a graph in dot format.</div><div class="ttdef"><b>Definition:</b> <a href="dot_8hpp_source.html#l00019">dot.hpp:19</a></div></div>
</div><!-- fragment --><p >However, there is also the option of providing a callback to which the vertices are passed and which can be used to add (<code>dot</code>) properties to the output from time to time:</p>
<div class="fragment"><div class="line">std::ostringstream output{};</div>
<div class="line"><a class="code hl_function" href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">entt::dot</a>(output, adjacency_matrix, [](<span class="keyword">auto</span> &amp;output, <span class="keyword">auto</span> vertex) {</div>
<div class="line">    out &lt;&lt; <span class="stringliteral">&quot;label=\&quot;v\&quot;&quot;</span> &lt;&lt; vertex &lt;&lt; <span class="stringliteral">&quot;,shape=\&quot;box\&quot;&quot;</span>;</div>
<div class="line">});</div>
</div><!-- fragment --><p >This second mode is particularly convenient when the user wants to associate data managed externally to the graph being converted.</p>
<h1><a class="anchor" id="autotoc_md122"></a>
Flow builder</h1>
<p >A flow builder is used to create execution graphs from tasks and resources.<br  />
 The implementation is as generic as possible and doesn't bind to any other part of the library.</p>
<p >This class is designed as a sort of <em>state machine</em> to which a specific task is attached for which the resources accessed in read-only or read-write mode are specified.<br  />
 Most of the functions in the API also return the flow builder itself, according to what is the common sense API when it comes to builder classes.</p>
<p >Once all tasks have been registered and resources assigned to them, an execution graph in the form of an adjacency matrix is returned to the user.<br  />
 This graph contains all the tasks assigned to the flow builder in the form of <em>vertices</em>. The <em>vertex</em> itself can be used as an index to get the identifier passed during registration.</p>
<h2><a class="anchor" id="autotoc_md123"></a>
Tasks and resources</h2>
<p >Although these terms are used extensively in the documentation, the flow builder has no real concept of tasks and resources.<br  />
 This class works mainly with <em>identifiers</em>, that is, values of type <code>id_type</code>. That is, both tasks and resources are identified by integral values.<br  />
 This allows not to couple the class itself to the rest of the library or to any particular data structure. On the other hand, it requires the user to keep track of the association between identifiers and operations or actual data.</p>
<p >Once a flow builder has been created (which requires no constructor arguments), the first thing to do is to bind a task. This will indicate to the builder who intends to consume the resources that will be specified immediately after:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentt_1_1basic__flow.html">entt::flow</a> builder{};</div>
<div class="line">builder.<a class="code hl_function" href="classentt_1_1basic__flow.html#a81236828df07e39e44a200debdd98a78">bind</a>(<span class="stringliteral">&quot;task_1&quot;</span>_hs);</div>
<div class="ttc" id="aclassentt_1_1basic__flow_html"><div class="ttname"><a href="classentt_1_1basic__flow.html">entt::basic_flow&lt;&gt;</a></div></div>
<div class="ttc" id="aclassentt_1_1basic__flow_html_a81236828df07e39e44a200debdd98a78"><div class="ttname"><a href="classentt_1_1basic__flow.html#a81236828df07e39e44a200debdd98a78">entt::basic_flow::bind</a></div><div class="ttdeci">basic_flow &amp; bind(const id_type value)</div><div class="ttdoc">Binds a task to a flow builder.</div><div class="ttdef"><b>Definition:</b> <a href="flow_8hpp_source.html#l00157">flow.hpp:157</a></div></div>
</div><!-- fragment --><p >Note that the example uses the <code>EnTT</code> hashed string to generate an identifier for the task.<br  />
 Indeed, the use of <code>id_type</code> as an identifier type is not by accident. In fact, it matches well with the internal hashed string class. Moreover, it's also the same type returned by the hash function of the internal RTTI system, in case the user wants to rely on that.<br  />
 However, being an integral value, it leaves the user full freedom to rely on his own tools if he deems it necessary.</p>
<p >Once a task has been associated with the flow builder, it can be assigned read-only or read-write resources, as appropriate:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
</div><!-- fragment --><p >As mentioned, many functions return the builder itself and it's therefore easy to concatenate the different calls.<br  />
 Also in the case of resources, these are identified by numeric values of type <code>id_type</code>. As above, the choice is not entirely random. This goes well with the tools offered by the library while leaving room for maximum flexibility.</p>
<p >Finally, both the <code>ro</code> and<code>rw</code> functions also offer an overload that accepts a pair of iterators, so that one can pass a range of resources in one go.</p>
<h2><a class="anchor" id="autotoc_md124"></a>
Fake resources and order of execution</h2>
<p >The flow builder doesn't offer the ability to specify when a task should execute before or after another task.<br  />
 In fact, the order of <em>registration</em> on the resources also determines the order in which the tasks are processed during the generation of the execution graph.</p>
<p >However, there is a way to force the execution order of two processes.<br  />
 Briefly, since accessing a resource in opposite modes requires sequential rather than parallel scheduling, it's possible to make use of fake resources to force the order execution:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_3&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
</div><!-- fragment --><p >This snippet forces the execution of <code>task_2</code> and <code>task_3</code> <b>after</b> <code>task_1</code>. This is due to the fact that the latter sets a read-write requirement on a fake resource that the other tasks also want to access in read-only mode.<br  />
 Similarly, it's possible to force a task to run after a certain group:</p>
<div class="fragment"><div class="line">builder</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_2&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_1&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
<div class="line">    .bind(<span class="stringliteral">&quot;task_3&quot;</span>_hs)</div>
<div class="line">        .ro(<span class="stringliteral">&quot;resource_2&quot;</span>_hs)</div>
<div class="line">        .rw(<span class="stringliteral">&quot;fake&quot;</span>_hs)</div>
</div><!-- fragment --><p >In this case, since there are a number of processes that want to read a specific resource, they will do so in parallel by forcing <code>task_3</code> to run after all the others tasks.</p>
<h2><a class="anchor" id="autotoc_md125"></a>
Sync points</h2>
<p >Sometimes it's useful to assign the role of <em>sync point</em> to a node.<br  />
 Whether it accesses new resources or is simply a watershed, the procedure for assigning this role to a vertex is always the same: first it's tied to the flow builder, then the <code>sync</code> function is invoked:</p>
<div class="fragment"><div class="line">builder.bind(<span class="stringliteral">&quot;sync_point&quot;</span>_hs).sync();</div>
</div><!-- fragment --><p >The choice to assign an <em>identity</em> to this type of nodes lies in the fact that, more often than not, they also perform operations on resources.<br  />
 If this isn't the case, it will still be possible to create no-op vertices to which empty tasks are assigned.</p>
<h2><a class="anchor" id="autotoc_md126"></a>
Execution graph</h2>
<p >Once both the resources and their consumers have been properly registered, the purpose of this tool is to generate an execution graph that takes into account all specified constraints to return the best scheduling for the vertices:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentt_1_1adjacency__matrix.html">entt::adjacency_matrix&lt;entt::directed_tag&gt;</a> graph = builder.graph();</div>
</div><!-- fragment --><p >The search for the main vertices, that is those without in-edges, is usually the first thing required:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;vertex: graph) {</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keyword">auto</span> in_edges = graph.in_edges(vertex); in_edges.begin() == in_edges.end()) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Starting from them, using the other functions appropriately (such as <code>out_edges</code> to retrieve the children of a given task or <code>edges</code> to access their identifiers) it will be possible to instantiate an execution graph. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
