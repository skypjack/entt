<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EnTT<span id="projectnumber">&#160;3.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">entt Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>EnTT</code> default namespace.  
<a href="namespaceentt.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1adjacency__matrix.html">adjacency_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a directed adjacency matrix.  <a href="classentt_1_1adjacency__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1adl__meta__pointer__like.html">adl_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake ADL based lookup function for meta pointer-like types.  <a href="structentt_1_1adl__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1allocation__deleter.html">allocation_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleter for allocator-aware unique pointers (waiting for C++20).  <a href="structentt_1_1allocation__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__cref__t.html">as_cref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as cref</em> policy.  <a href="structentt_1_1as__cref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1as__group.html">as_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a group.  <a href="classentt_1_1as__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__is__t.html">as_is_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as-is</em> policy.  <a href="structentt_1_1as__is__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__ref__t.html">as_ref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as ref</em> policy.  <a href="structentt_1_1as__ref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1as__view.html">as_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a view.  <a href="classentt_1_1as__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__void__t.html">as_void_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as void</em> policy.  <a href="structentt_1_1as__void__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__any.html">basic_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SBO friendly, type-safe container for single values of any type.  <a href="classentt_1_1basic__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector.html">basic_collector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html">basic_collector&lt; matcher&lt; type_list&lt; Reject... &gt;, type_list&lt; Require... &gt;, Rule... &gt;, Other... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_4.html">basic_collector&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for <em>continuous loading</em>.  <a href="classentt_1_1basic__continuous__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__dispatcher.html">basic_dispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic dispatcher implementation.  <a href="classentt_1_1basic__dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__flow.html">basic_flow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating task graphs.  <a href="classentt_1_1basic__flow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group.html">basic_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group.  <a href="classentt_1_1basic__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01owned__t_3_01Owned_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_00_011bc3c06bb47de7bb72ca45b6e209ac72.html">basic_group&lt; owned_t&lt; Owned... &gt;, get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning group.  <a href="classentt_1_1basic__group_3_01owned__t_3_01Owned_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_00_011bc3c06bb47de7bb72ca45b6e209ac72.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01owned__t_3_4_00_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html">basic_group&lt; owned_t&lt;&gt;, get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning group.  <a href="classentt_1_1basic__group_3_01owned__t_3_4_00_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__handle.html">basic_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning handle to an entity.  <a href="structentt_1_1basic__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero overhead unique identifier.  <a href="classentt_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__observer.html">basic_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer.  <a href="classentt_1_1basic__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating a static task graph.  <a href="classentt_1_1basic__organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__poly.html">basic_poly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static polymorphism made simple and within everyone's reach.  <a href="classentt_1_1basic__poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast and reliable entity-component system.  <a href="classentt_1_1basic__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic runtime view.  <a href="classentt_1_1basic__runtime__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create snapshots from a registry.  <a href="classentt_1_1basic__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to restore a snapshot as a whole.  <a href="classentt_1_1basic__snapshot__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic sparse set implementation.  <a href="classentt_1_1basic__sparse__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="classentt_1_1basic__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage_3_01Type_00_01Entity_00_01Allocator_00_01std_1_1enable__if__t_3_01ig194a4e28bc0d25794aef0e0ea5accf21.html">basic_storage&lt; Type, Entity, Allocator, std::enable_if_t&lt; ignore_as_empty_v&lt; Type &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classentt_1_1basic__storage_3_01Type_00_01Entity_00_01Allocator_00_01std_1_1enable__if__t_3_01ig194a4e28bc0d25794aef0e0ea5accf21.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view.html">basic_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View implementation.  <a href="classentt_1_1basic__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01get__t_3_01Get_01_4_00_01exclude__t_3_4_00_01std_1_1void__t_3_01std94c1472c52e119e81095a53d4557cdae.html">basic_view&lt; get_t&lt; Get &gt;, exclude_t&lt;&gt;, std::void_t&lt; std::enable_if_t&lt;!component_traits&lt; typename Get::value_type &gt;::in_place_delete &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single component view specialization.  <a href="classentt_1_1basic__view_3_01get__t_3_01Get_01_4_00_01exclude__t_3_4_00_01std_1_1void__t_3_01std94c1472c52e119e81095a53d4557cdae.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html">basic_view&lt; get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi component view.  <a href="classentt_1_1basic__view_3_01get__t_3_01Get_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t.html">choice_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t_3_010_01_4.html">choice_t&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1component__traits.html">component_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common way to access various properties of components.  <a href="structentt_1_1component__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compressed pair.  <a href="classentt_1_1compressed__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tag for constructors and the like.  <a href="structentt_1_1connect__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection class.  <a href="classentt_1_1connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as.html">constness_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html">constness_as&lt; To, const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate.html">delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic delegate implementation.  <a href="classentt_1_1delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html">delegate&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to use to send around functions and members.  <a href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dense__map.html">dense_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container for key-value pairs with unique keys.  <a href="classentt_1_1dense__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dense__set.html">dense_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container for unique objects of a given type.  <a href="classentt_1_1dense__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1directed__tag.html">directed_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undirected graph category tag.  <a href="structentt_1_1directed__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1emitter.html">emitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose event emitter.  <a href="classentt_1_1emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1entt__traits.html">entt_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits.  <a href="classentt_1_1entt__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable bitmask support for enum classes.  <a href="structentt_1_1enum__as__bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1enum__as__bitmask_3_01Type_00_01std_1_1void__t_3_01decltype_07Type_1_1__entt__enum__as__bitmask_08_4_01_4.html">enum_as_bitmask&lt; Type, std::void_t&lt; decltype(Type::_entt_enum_as_bitmask)&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable bitmask support for enum classes.  <a href="structentt_1_1enum__as__bitmask_3_01Type_00_01std_1_1void__t_3_01decltype_07Type_1_1__entt__enum__as__bitmask_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1family.html">family</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic identifier generator.  <a href="classentt_1_1family.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1forward__apply.html">forward_apply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to forward-and-apply tuple objects.  <a href="structentt_1_1forward__apply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1ident.html">ident</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type integral identifiers.  <a href="classentt_1_1ident.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function object (waiting for C++20).  <a href="structentt_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1input__iterator__pointer.html">input_iterator_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to use as pointer with input iterators.  <a href="structentt_1_1input__iterator__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1insertion__sort.html">insertion_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing insertion sort.  <a href="structentt_1_1insertion__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain iota iterator (waiting for C++20).  <a href="classentt_1_1iota__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable.html">is_applicable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, const Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable_r&lt; Ret, Func, std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete.html">is_complete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">is_complete&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is both an empty and non-final class, false otherwise.  <a href="structentt_1_1is__ebco__eligible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable_3_01Type_00_01std_1_1void__t_3_01decltype_07std_1_1declva46aebf4c20f38cbd0108d1e297595736.html">is_equality_comparable&lt; Type, std::void_t&lt; decltype(std::declval&lt; Type &gt;()==std::declval&lt; Type &gt;())&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable_3_01Type_00_01std_1_1void__t_3_01decltype_07std_1_1declva46aebf4c20f38cbd0108d1e297595736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.  <a href="structentt_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator_3_01Type_00_01std_1_1enable__if__t_3_9std_1_1is__same__v_3_01std_1_1rb11209056dad14b6f2d16527c535258a.html">is_iterator&lt; Type, std::enable_if_t&lt;!std::is_same_v&lt; std::remove_cv_t&lt; std::remove_pointer_t&lt; Type &gt; &gt;, void &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.  <a href="structentt_1_1is__iterator_3_01Type_00_01std_1_1enable__if__t_3_9std_1_1is__same__v_3_01std_1_1rb11209056dad14b6f2d16527c535258a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a pointer-like type from the point of view of the meta system, false otherwise.  <a href="structentt_1_1is__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html">is_meta_pointer_like&lt; const Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization to ensure that const pointer-like types are also accepted.  <a href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html">is_meta_pointer_like&lt; std::shared_ptr&lt; Type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::shared_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html">is_meta_pointer_like&lt; std::unique_ptr&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::unique_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html">is_meta_pointer_like&lt; Type * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes plain pointers pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html">is_meta_pointer_like&lt; Type(*)[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization used to reject pointers to arrays.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__policy.html">is_meta_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type also is a meta policy, false otherwise.  <a href="structentt_1_1is__meta__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__transparent.html">is_transparent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if <code>Type::is_transparent</code> is valid and denotes a type, false otherwise.  <a href="structentt_1_1is__transparent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__transparent_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__transparent_01_4_01_4.html">is_transparent&lt; Type, std::void_t&lt; typename Type::is_transparent &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if <code>Type::is_transparent</code> is valid and denotes a type, false otherwise.  <a href="structentt_1_1is__transparent_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__transparent_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a tuple, false otherwise.  <a href="structentt_1_1is__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create an iterable object from a pair of iterators.  <a href="structentt_1_1iterable__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1locator.html">locator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service locator, nothing more.  <a href="classentt_1_1locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1matcher.html">matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grouping matcher.  <a href="structentt_1_1matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1member__class.html">member_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class of a non-static member object or function.  <a href="classentt_1_1member__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__any.html">meta_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for values of any type.  <a href="classentt_1_1meta__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__associative__container.html">meta_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for associative containers.  <a href="classentt_1_1meta__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits.html">meta_associative_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta associative containers.  <a href="structentt_1_1meta__associative__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01dense__map_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; dense_map&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code><a class="el" href="classentt_1_1dense__map.html" title="Associative container for key-value pairs with unique keys.">dense_map</a></code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01dense__map_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01dense__set_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; dense_set&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code><a class="el" href="classentt_1_1dense__set.html" title="Associative container for unique objects of a given type.">dense_set</a></code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01dense__set_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::map&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::set&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_map&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_set&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__class__template__tag.html">meta_class_template_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate class templates.  <a href="structentt_1_1meta__class__template__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque meta context type.  <a href="classentt_1_1meta__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__ctx__arg__t.html">meta_ctx_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tag for constructors and the like.  <a href="classentt_1_1meta__ctx__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__data.html">meta_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for data members.  <a href="structentt_1_1meta__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__factory.html">meta_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic meta factory to be used for reflection purposes.  <a href="classentt_1_1meta__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__func.html">meta_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for member functions.  <a href="structentt_1_1meta__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor.html">meta_function_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1meta__function__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_01Class_1_1_5_01_4.html">meta_function_descriptor&lt; Type, Ret Class::* &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_01Class_1_1_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07_08_4.html">meta_function_descriptor&lt; Type, Ret(*)()&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07MaybeType_00_01Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(*)(MaybeType, Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07MaybeType_00_01Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor__traits.html">meta_function_descriptor_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor traits.  <a href="structentt_1_1meta__function__descriptor__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function helper.  <a href="classentt_1_1meta__function__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointers to instances of any type.  <a href="structentt_1_1meta__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__prop.html">meta_prop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for properties of any type.  <a href="structentt_1_1meta__prop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__sequence__container.html">meta_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for sequence containers.  <a href="classentt_1_1meta__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits.html">meta_sequence_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta sequence containers.  <a href="structentt_1_1meta__sequence__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html">meta_sequence_container_traits&lt; std::array&lt; Type, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::array</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1deque_3_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::deque&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::deque</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1deque_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1list_3_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::list&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::list</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1list_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::vector&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::vector</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits.html">meta_template_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta template information.  <a href="structentt_1_1meta__template__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html">meta_template_traits&lt; Clazz&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose traits class for generating meta template information.  <a href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__type.html">meta_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for types.  <a href="classentt_1_1meta__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal implementation of the monostate pattern.  <a href="structentt_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1nth__argument.html">nth_argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the n-th argument of a given function or member function.  <a href="classentt_1_1nth__argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1null__t.html">null_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null object for all identifiers. <br  />
  <a href="structentt_1_1null__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1overloaded.html">overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for visitors.  <a href="structentt_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__base.html">poly_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poly base class used to inject functionalities into concepts.  <a href="structentt_1_1poly__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__inspector.html">poly_inspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector class used to infer the type of the virtual table.  <a href="structentt_1_1poly__inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1poly__vtable.html">poly_vtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static virtual table factory.  <a href="classentt_1_1poly__vtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1process.html">process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for processes.  <a href="classentt_1_1process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1process__adaptor.html">process_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for lambdas and functors to turn them into processes.  <a href="structentt_1_1process__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1radix__sort.html">radix_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing LSD radix sort.  <a href="structentt_1_1radix__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource.html">resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic resource handle.  <a href="classentt_1_1resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__cache.html">resource_cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic cache for resources of any type.  <a href="classentt_1_1resource__cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1resource__loader.html">resource_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transparent loader for shared resources.  <a href="structentt_1_1resource__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooperative scheduler for processes.  <a href="classentt_1_1scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1scoped__connection.html">scoped_connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scoped connection class.  <a href="structentt_1_1scoped__connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh.html">sigh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4.html">sigh&lt; Ret(Args...), Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh__storage__mixin.html">sigh_storage_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type used to add signal support to storage types.  <a href="classentt_1_1sigh__storage__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink_3_01sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4_01_4.html">sink&lt; sigh&lt; Ret(Args...), Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink_3_01sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of.html">size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">size_of&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1std__sort.html">std_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to wrap <code>std::sort</code> in a class type.  <a href="structentt_1_1std__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__for.html">storage_for</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__type.html">storage_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a common way to define storage types.  <a href="structentt_1_1storage__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tombstone object for all identifiers. <br  />
  <a href="structentt_1_1tombstone__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__hash.html">type_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type hash.  <a href="structentt_1_1type__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__identity.html">type_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity type trait.  <a href="structentt_1_1type__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__index.html">type_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type sequential identifier.  <a href="structentt_1_1type__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__info.html">type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation specific information about a type.  <a href="structentt_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of types, nothing more.  <a href="structentt_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_4.html">type_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html">type_list_contains&lt; type_list&lt; Type... &gt;, Other &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html">type_list_diff&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference between two type lists.  <a href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element.html">type_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; 0u, type_list&lt; First, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; Index, type_list&lt; First, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index.html">type_list_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html">type_list_index&lt; Type, type_list&lt; First, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the types of a type list.  <a href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01First_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_index&lt; Type, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the types of a type list.  <a href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_4_01_4.html">type_list_index&lt; Type, type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time type access to the types of a type list.  <a href="structentt_1_1type__list__index_3_01Type_00_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__transform.html">type_list_transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__transform_3_01type__list_3_01Type_8_8_8_01_4_00_01Op_01_4.html">type_list_transform&lt; type_list&lt; Type... &gt;, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a given <em>function</em> to a type list and generate a new list.  <a href="structentt_1_1type__list__transform_3_01type__list_3_01Type_8_8_8_01_4_00_01Op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_unique&lt; type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html">type_list_unique&lt; type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__name.html">type_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type name.  <a href="structentt_1_1type__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1undirected__tag.html">undirected_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directed graph category tag.  <a href="structentt_1_1undirected__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list.html">value_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of constant values, nothing more.  <a href="structentt_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt;, value_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_4.html">value_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element.html">value_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; 0u, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; Index, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the values of a value list.  <a href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1y__combinator.html">y_combinator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a y-combinator.  <a href="structentt_1_1y__combinator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> = std::uint32_t</td></tr>
<tr class="memdesc:a13e040e7b38a8f86d1ab2f096f37b627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for type identifiers.  <a href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">More...</a><br /></td></tr>
<tr class="separator:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4846741b8f485584c196304f588b94ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4846741b8f485584c196304f588b94ad">any</a> = <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;&gt;</td></tr>
<tr class="memdesc:a4846741b8f485584c196304f588b94ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a4846741b8f485584c196304f588b94ad">More...</a><br /></td></tr>
<tr class="separator:a4846741b8f485584c196304f588b94ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">hashed_string</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a8f9dd22ce26cd7913a294b3fd520649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types.  <a href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">More...</a><br /></td></tr>
<tr class="separator:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2768719b1f5967caf5836b2656d0ed6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">hashed_wstring</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:af2768719b1f5967caf5836b2656d0ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types.  <a href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">More...</a><br /></td></tr>
<tr class="separator:af2768719b1f5967caf5836b2656d0ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">type_identity_t</a> = typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">More...</a><br /></td></tr>
<tr class="separator:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62c84ccab78132ef356b13e4ff12dfa"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename &gt; </td></tr>
<tr class="memitem:ae62c84ccab78132ef356b13e4ff12dfa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae62c84ccab78132ef356b13e4ff12dfa">unpack_as_type</a> = Type</td></tr>
<tr class="memdesc:ae62c84ccab78132ef356b13e4ff12dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#ae62c84ccab78132ef356b13e4ff12dfa">More...</a><br /></td></tr>
<tr class="separator:ae62c84ccab78132ef356b13e4ff12dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplParams" colspan="2">template&lt;auto Value&gt; </td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a> = std::integral_constant&lt; decltype(Value), Value &gt;</td></tr>
<tr class="memdesc:a0d9fd5898acf13553bbcf14b99159f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a static constant.  <a href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">More...</a><br /></td></tr>
<tr class="separator:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> Value&gt; </td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">tag</a> = <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt; Value &gt;</td></tr>
<tr class="memdesc:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the creation of named values.  <a href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">More...</a><br /></td></tr>
<tr class="separator:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">type_list_element_t</a> = typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt; Index, List &gt;::type</td></tr>
<tr class="memdesc:ac839c1a03dba2436791d0056d6d0d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">More...</a><br /></td></tr>
<tr class="separator:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">type_list_cat_t</a> = typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a546467a3662e9a915d5d519ad565e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">More...</a><br /></td></tr>
<tr class="separator:a546467a3662e9a915d5d519ad565e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">type_list_unique_t</a> = typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a75a277a6037279d65cd3874b46ec7166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">More...</a><br /></td></tr>
<tr class="separator:a75a277a6037279d65cd3874b46ec7166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">type_list_diff_t</a> = typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:af2992fc009cb3199b0ef9a86bed2285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">More...</a><br /></td></tr>
<tr class="separator:af2992fc009cb3199b0ef9a86bed2285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbdb52103a951e6ff27b40765c52975"><td class="memTemplParams" colspan="2">template&lt;typename List , template&lt; typename... &gt; class Op&gt; </td></tr>
<tr class="memitem:a4cbdb52103a951e6ff27b40765c52975"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a> = typename <a class="el" href="structentt_1_1type__list__transform.html">type_list_transform</a>&lt; List, Op &gt;::type</td></tr>
<tr class="memdesc:a4cbdb52103a951e6ff27b40765c52975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">More...</a><br /></td></tr>
<tr class="separator:a4cbdb52103a951e6ff27b40765c52975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">value_list_cat_t</a> = typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a1344cc62598091397018354e6905e431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a1344cc62598091397018354e6905e431">More...</a><br /></td></tr>
<tr class="separator:a1344cc62598091397018354e6905e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a> = typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt; To, From &gt;::type</td></tr>
<tr class="memdesc:a7b051461867d3c5c97f77f10b662c26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the transcription of the constness.  <a href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">More...</a><br /></td></tr>
<tr class="separator:a7b051461867d3c5c97f77f10b662c26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplParams" colspan="2">template&lt;typename Member &gt; </td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">member_class_t</a> = typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt; Member &gt;::type</td></tr>
<tr class="memdesc:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">More...</a><br /></td></tr>
<tr class="separator:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b51f34944eb75076ee9710c939f4aa"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, auto Candidate&gt; </td></tr>
<tr class="memitem:ae5b51f34944eb75076ee9710c939f4aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae5b51f34944eb75076ee9710c939f4aa">nth_argument_t</a> = typename <a class="el" href="classentt_1_1nth__argument.html">nth_argument</a>&lt; Index, Candidate &gt;::type</td></tr>
<tr class="memdesc:ae5b51f34944eb75076ee9710c939f4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#ae5b51f34944eb75076ee9710c939f4aa">More...</a><br /></td></tr>
<tr class="separator:ae5b51f34944eb75076ee9710c939f4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806da7d3930a8e5fff66e8f4be841f44"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a806da7d3930a8e5fff66e8f4be841f44"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">exclude_t</a> = <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;</td></tr>
<tr class="memdesc:a806da7d3930a8e5fff66e8f4be841f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for exclusion lists.  <a href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">More...</a><br /></td></tr>
<tr class="separator:a806da7d3930a8e5fff66e8f4be841f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0848971d27a69686665fb953fc62f4df"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a0848971d27a69686665fb953fc62f4df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">get_t</a> = <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;</td></tr>
<tr class="memdesc:a0848971d27a69686665fb953fc62f4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of observed components.  <a href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">More...</a><br /></td></tr>
<tr class="separator:a0848971d27a69686665fb953fc62f4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dd3ca7c921555e1635fde386d9b243"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a68dd3ca7c921555e1635fde386d9b243"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a68dd3ca7c921555e1635fde386d9b243">owned_t</a> = <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;</td></tr>
<tr class="memdesc:a68dd3ca7c921555e1635fde386d9b243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of owned components.  <a href="namespaceentt.html#a68dd3ca7c921555e1635fde386d9b243">More...</a><br /></td></tr>
<tr class="separator:a68dd3ca7c921555e1635fde386d9b243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f06dabf02e7aca639b4fa0bb84dc283"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2f06dabf02e7aca639b4fa0bb84dc283">sparse_set</a> = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt;&gt;</td></tr>
<tr class="memdesc:a2f06dabf02e7aca639b4fa0bb84dc283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a2f06dabf02e7aca639b4fa0bb84dc283">More...</a><br /></td></tr>
<tr class="separator:a2f06dabf02e7aca639b4fa0bb84dc283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7ab17a0233eb285971b211e3128249"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a5c7ab17a0233eb285971b211e3128249"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5c7ab17a0233eb285971b211e3128249">storage</a> = <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; Type &gt;</td></tr>
<tr class="memdesc:a5c7ab17a0233eb285971b211e3128249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a5c7ab17a0233eb285971b211e3128249">More...</a><br /></td></tr>
<tr class="separator:a5c7ab17a0233eb285971b211e3128249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52578c5714150de197f815c62899bce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> = <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;&gt;</td></tr>
<tr class="memdesc:ac52578c5714150de197f815c62899bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#ac52578c5714150de197f815c62899bce">More...</a><br /></td></tr>
<tr class="separator:ac52578c5714150de197f815c62899bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7436015f2d06bbaeeac5ba0519786b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0a7436015f2d06bbaeeac5ba0519786b">observer</a> = <a class="el" href="classentt_1_1basic__observer.html">basic_observer</a>&lt; <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> &gt;</td></tr>
<tr class="memdesc:a0a7436015f2d06bbaeeac5ba0519786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a0a7436015f2d06bbaeeac5ba0519786b">More...</a><br /></td></tr>
<tr class="separator:a0a7436015f2d06bbaeeac5ba0519786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1035ac7ff12b6a8b59ee9dbdf9e9abc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad1035ac7ff12b6a8b59ee9dbdf9e9abc">organizer</a> = <a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a>&lt; <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> &gt;</td></tr>
<tr class="memdesc:ad1035ac7ff12b6a8b59ee9dbdf9e9abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#ad1035ac7ff12b6a8b59ee9dbdf9e9abc">More...</a><br /></td></tr>
<tr class="separator:ad1035ac7ff12b6a8b59ee9dbdf9e9abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2482f76c688f8d89f2b3c4cd03bf4be3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2482f76c688f8d89f2b3c4cd03bf4be3">handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> &gt;</td></tr>
<tr class="memdesc:a2482f76c688f8d89f2b3c4cd03bf4be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a2482f76c688f8d89f2b3c4cd03bf4be3">More...</a><br /></td></tr>
<tr class="separator:a2482f76c688f8d89f2b3c4cd03bf4be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdfab053e66e33baa359f8d48d3d36d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abbdfab053e66e33baa359f8d48d3d36d">const_handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> &gt;</td></tr>
<tr class="memdesc:abbdfab053e66e33baa359f8d48d3d36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#abbdfab053e66e33baa359f8d48d3d36d">More...</a><br /></td></tr>
<tr class="separator:abbdfab053e66e33baa359f8d48d3d36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba3a637756cc5dce61ba276a6f8e3e6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afba3a637756cc5dce61ba276a6f8e3e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afba3a637756cc5dce61ba276a6f8e3e6">handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>, Args... &gt;</td></tr>
<tr class="memdesc:afba3a637756cc5dce61ba276a6f8e3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#afba3a637756cc5dce61ba276a6f8e3e6">More...</a><br /></td></tr>
<tr class="separator:afba3a637756cc5dce61ba276a6f8e3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df5147166e6d4b8c60ebb737146d9a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a45df5147166e6d4b8c60ebb737146d9a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a45df5147166e6d4b8c60ebb737146d9a">const_handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>, Args... &gt;</td></tr>
<tr class="memdesc:a45df5147166e6d4b8c60ebb737146d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a45df5147166e6d4b8c60ebb737146d9a">More...</a><br /></td></tr>
<tr class="separator:a45df5147166e6d4b8c60ebb737146d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793026b4107ee09e64d9759814db86ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a793026b4107ee09e64d9759814db86ff">snapshot</a> = <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt; <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> &gt;</td></tr>
<tr class="memdesc:a793026b4107ee09e64d9759814db86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a793026b4107ee09e64d9759814db86ff">More...</a><br /></td></tr>
<tr class="separator:a793026b4107ee09e64d9759814db86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ade3d6bdcf2d53899ab2213a26327ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7ade3d6bdcf2d53899ab2213a26327ca">snapshot_loader</a> = <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt; <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> &gt;</td></tr>
<tr class="memdesc:a7ade3d6bdcf2d53899ab2213a26327ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a7ade3d6bdcf2d53899ab2213a26327ca">More...</a><br /></td></tr>
<tr class="separator:a7ade3d6bdcf2d53899ab2213a26327ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8516c2683fa3eed9e5f2e6c63ed8082"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af8516c2683fa3eed9e5f2e6c63ed8082">continuous_loader</a> = <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt; <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a> &gt;</td></tr>
<tr class="memdesc:af8516c2683fa3eed9e5f2e6c63ed8082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#af8516c2683fa3eed9e5f2e6c63ed8082">More...</a><br /></td></tr>
<tr class="separator:af8516c2683fa3eed9e5f2e6c63ed8082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c62599319bf5730fb872b759dbed716"><td class="memTemplParams" colspan="2">template&lt;typename Get , typename Exclude  = exclude_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:a4c62599319bf5730fb872b759dbed716"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4c62599319bf5730fb872b759dbed716">view</a> = <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt; Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a> &gt;, <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt; Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a> &gt; &gt;</td></tr>
<tr class="memdesc:a4c62599319bf5730fb872b759dbed716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a4c62599319bf5730fb872b759dbed716">More...</a><br /></td></tr>
<tr class="separator:a4c62599319bf5730fb872b759dbed716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1433f3effac40f4a6d1b92b89f68e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4d1433f3effac40f4a6d1b92b89f68e9">runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt; <a class="el" href="namespaceentt.html#a2f06dabf02e7aca639b4fa0bb84dc283">sparse_set</a> &gt;</td></tr>
<tr class="memdesc:a4d1433f3effac40f4a6d1b92b89f68e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a4d1433f3effac40f4a6d1b92b89f68e9">More...</a><br /></td></tr>
<tr class="separator:a4d1433f3effac40f4a6d1b92b89f68e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26624baa492b8703941b003545d19519"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a26624baa492b8703941b003545d19519">const_runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt; const <a class="el" href="namespaceentt.html#a2f06dabf02e7aca639b4fa0bb84dc283">sparse_set</a> &gt;</td></tr>
<tr class="memdesc:a26624baa492b8703941b003545d19519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a26624baa492b8703941b003545d19519">More...</a><br /></td></tr>
<tr class="separator:a26624baa492b8703941b003545d19519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692d5f7362f72f433e9e7fa0447507dd"><td class="memTemplParams" colspan="2">template&lt;typename Owned , typename Get , typename Exclude &gt; </td></tr>
<tr class="memitem:a692d5f7362f72f433e9e7fa0447507dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a692d5f7362f72f433e9e7fa0447507dd">group</a> = <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt; <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt; Owned, <a class="el" href="structentt_1_1storage__for.html">storage_for</a> &gt;, <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt; Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a> &gt;, <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt; Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a> &gt; &gt;</td></tr>
<tr class="memdesc:a692d5f7362f72f433e9e7fa0447507dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a692d5f7362f72f433e9e7fa0447507dd">More...</a><br /></td></tr>
<tr class="separator:a692d5f7362f72f433e9e7fa0447507dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c15d729cd7fd9184864a36e0a49097"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae2c15d729cd7fd9184864a36e0a49097"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae2c15d729cd7fd9184864a36e0a49097">storage_type_t</a> = typename <a class="el" href="structentt_1_1storage__type.html">storage_type</a>&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ae2c15d729cd7fd9184864a36e0a49097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#ae2c15d729cd7fd9184864a36e0a49097">More...</a><br /></td></tr>
<tr class="separator:ae2c15d729cd7fd9184864a36e0a49097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609a0599bbe1da577674a4898f18a35b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a609a0599bbe1da577674a4898f18a35b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a609a0599bbe1da577674a4898f18a35b">storage_for_t</a> = typename <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:a609a0599bbe1da577674a4898f18a35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a609a0599bbe1da577674a4898f18a35b">More...</a><br /></td></tr>
<tr class="separator:a609a0599bbe1da577674a4898f18a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5cc1a771624f5b46912cfd5a30bb67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2d5cc1a771624f5b46912cfd5a30bb67">flow</a> = <a class="el" href="classentt_1_1basic__flow.html">basic_flow</a>&lt;&gt;</td></tr>
<tr class="memdesc:a2d5cc1a771624f5b46912cfd5a30bb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a2d5cc1a771624f5b46912cfd5a30bb67">More...</a><br /></td></tr>
<tr class="separator:a2d5cc1a771624f5b46912cfd5a30bb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a0f990ac8ad302430ef72224fb02eb"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename It &gt; </td></tr>
<tr class="memitem:a19a0f990ac8ad302430ef72224fb02eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a19a0f990ac8ad302430ef72224fb02eb">meta_range</a> = <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt; internal::meta_range_iterator&lt; Type, It &gt; &gt;</td></tr>
<tr class="memdesc:a19a0f990ac8ad302430ef72224fb02eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable range to use to iterate all types of meta objects.  <a href="namespaceentt.html#a19a0f990ac8ad302430ef72224fb02eb">More...</a><br /></td></tr>
<tr class="separator:a19a0f990ac8ad302430ef72224fb02eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Candidate &gt; </td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">meta_function_helper_t</a> = typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt; Type, Candidate &gt;::type</td></tr>
<tr class="memdesc:a692beabf853ee0f9dc68beab816a6b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">More...</a><br /></td></tr>
<tr class="separator:a692beabf853ee0f9dc68beab816a6b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c6f86f6643c525f654540c3d4c6819"><td class="memTemplParams" colspan="2">template&lt;typename Concept &gt; </td></tr>
<tr class="memitem:a53c6f86f6643c525f654540c3d4c6819"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a53c6f86f6643c525f654540c3d4c6819">poly</a> = <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt; Concept &gt;</td></tr>
<tr class="memdesc:a53c6f86f6643c525f654540c3d4c6819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a53c6f86f6643c525f654540c3d4c6819">More...</a><br /></td></tr>
<tr class="separator:a53c6f86f6643c525f654540c3d4c6819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e500ff0298787e120786c6247ba7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3b9e500ff0298787e120786c6247ba7c">dispatcher</a> = <a class="el" href="classentt_1_1basic__dispatcher.html">basic_dispatcher</a>&lt;&gt;</td></tr>
<tr class="memdesc:a3b9e500ff0298787e120786c6247ba7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a3b9e500ff0298787e120786c6247ba7c">More...</a><br /></td></tr>
<tr class="separator:a3b9e500ff0298787e120786c6247ba7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0b54e231d069e8a231e14b223388808a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> : id_type </td></tr>
<tr class="memdesc:a0b54e231d069e8a231e14b223388808a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default entity identifier.  <a href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">More...</a><br /></td></tr>
<tr class="separator:a0b54e231d069e8a231e14b223388808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d0fa77fae26e7c01793990996c581"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> : std::uint8_t { <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708">swap_and_pop</a> = 0u
, <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28">in_place</a> = 1u
 }</td></tr>
<tr class="memdesc:abc4d0fa77fae26e7c01793990996c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse set deletion policy.  <a href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">More...</a><br /></td></tr>
<tr class="separator:abc4d0fa77fae26e7c01793990996c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab5824be13d8a7ef8976f580ab3ffeb2c">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#ab5824be13d8a7ef8976f580ab3ffeb2c">More...</a><br /></td></tr>
<tr class="separator:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb671c6d5af5e797eca1fadb1980e72"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:abfb671c6d5af5e797eca1fadb1980e72"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abfb671c6d5af5e797eca1fadb1980e72">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:abfb671c6d5af5e797eca1fadb1980e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#abfb671c6d5af5e797eca1fadb1980e72">More...</a><br /></td></tr>
<tr class="separator:abfb671c6d5af5e797eca1fadb1980e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336c64e72007016b8c8dcb7ccc70468f"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a336c64e72007016b8c8dcb7ccc70468f"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a336c64e72007016b8c8dcb7ccc70468f">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;data) noexcept</td></tr>
<tr class="memdesc:a336c64e72007016b8c8dcb7ccc70468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a336c64e72007016b8c8dcb7ccc70468f">More...</a><br /></td></tr>
<tr class="separator:a336c64e72007016b8c8dcb7ccc70468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf666ed024f5542f987b8b5a658f64"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:aaabf666ed024f5542f987b8b5a658f64"><td class="memTemplItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaabf666ed024f5542f987b8b5a658f64">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data) noexcept</td></tr>
<tr class="memdesc:aaabf666ed024f5542f987b8b5a658f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#aaabf666ed024f5542f987b8b5a658f64">More...</a><br /></td></tr>
<tr class="separator:aaabf666ed024f5542f987b8b5a658f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae0b7dd1eaac2e05f42febf94331e1ac0">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data) noexcept</td></tr>
<tr class="memdesc:ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#ae0b7dd1eaac2e05f42febf94331e1ac0">More...</a><br /></td></tr>
<tr class="separator:ae0b7dd1eaac2e05f42febf94331e1ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb86dc3145589485c094960a089eb953"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </td></tr>
<tr class="memitem:adb86dc3145589485c094960a089eb953"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adb86dc3145589485c094960a089eb953">make_any</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:adb86dc3145589485c094960a089eb953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a wrapper from a given type, passing it all arguments.  <a href="namespaceentt.html#adb86dc3145589485c094960a089eb953">More...</a><br /></td></tr>
<tr class="separator:adb86dc3145589485c094960a089eb953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02fa96c663a6706416e47a3a6658328"><td class="memTemplParams" colspan="2">template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type &gt; </td></tr>
<tr class="memitem:af02fa96c663a6706416e47a3a6658328"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af02fa96c663a6706416e47a3a6658328">forward_as_any</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:af02fa96c663a6706416e47a3a6658328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <a href="namespaceentt.html#af02fa96c663a6706416e47a3a6658328">More...</a><br /></td></tr>
<tr class="separator:af02fa96c663a6706416e47a3a6658328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93ac21ff904a1ba357caf8ea40cd7f"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Other &gt; </td></tr>
<tr class="memitem:afd93ac21ff904a1ba357caf8ea40cd7f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afd93ac21ff904a1ba357caf8ea40cd7f">compressed_pair</a> (Type &amp;&amp;, Other &amp;&amp;) -&gt; <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; std::decay_t&lt; Type &gt;, std::decay_t&lt; Other &gt; &gt;</td></tr>
<tr class="memdesc:afd93ac21ff904a1ba357caf8ea40cd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#afd93ac21ff904a1ba357caf8ea40cd7f">More...</a><br /></td></tr>
<tr class="separator:afd93ac21ff904a1ba357caf8ea40cd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85aff290a542f0f053b993b507410b21"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second &gt; </td></tr>
<tr class="memitem:a85aff290a542f0f053b993b507410b21"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85aff290a542f0f053b993b507410b21">swap</a> (<a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;lhs, <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a85aff290a542f0f053b993b507410b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two compressed pair objects.  <a href="namespaceentt.html#a85aff290a542f0f053b993b507410b21">More...</a><br /></td></tr>
<tr class="separator:a85aff290a542f0f053b993b507410b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2238bd6227a1ee3da75a6d4d224c589e"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a2238bd6227a1ee3da75a6d4d224c589e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2238bd6227a1ee3da75a6d4d224c589e">basic_hashed_string</a> (const Char *str, const std::size_t len) -&gt; <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td></tr>
<tr class="memdesc:a2238bd6227a1ee3da75a6d4d224c589e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a2238bd6227a1ee3da75a6d4d224c589e">More...</a><br /></td></tr>
<tr class="separator:a2238bd6227a1ee3da75a6d4d224c589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplParams" colspan="2">template&lt;typename Char , std::size_t N&gt; </td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa97361ef962166a4fc51a582d7c6392">basic_hashed_string</a> (const Char(&amp;str)[N]) -&gt; <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td></tr>
<tr class="memdesc:aaa97361ef962166a4fc51a582d7c6392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aaa97361ef962166a4fc51a582d7c6392">More...</a><br /></td></tr>
<tr class="separator:aaa97361ef962166a4fc51a582d7c6392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c61951b721a1e3612cf536bd707501"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:af7c61951b721a1e3612cf536bd707501"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af7c61951b721a1e3612cf536bd707501">operator==</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af7c61951b721a1e3612cf536bd707501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#af7c61951b721a1e3612cf536bd707501">More...</a><br /></td></tr>
<tr class="separator:af7c61951b721a1e3612cf536bd707501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9accc71a383509ada028f7fa2b767bf"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:ad9accc71a383509ada028f7fa2b767bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad9accc71a383509ada028f7fa2b767bf">operator!=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad9accc71a383509ada028f7fa2b767bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#ad9accc71a383509ada028f7fa2b767bf">More...</a><br /></td></tr>
<tr class="separator:ad9accc71a383509ada028f7fa2b767bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88e297d57dd5547afcde8dd291c4b8f"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:aa88e297d57dd5547afcde8dd291c4b8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa88e297d57dd5547afcde8dd291c4b8f">operator&lt;</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa88e297d57dd5547afcde8dd291c4b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#aa88e297d57dd5547afcde8dd291c4b8f">More...</a><br /></td></tr>
<tr class="separator:aa88e297d57dd5547afcde8dd291c4b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c763e890bb00479a6a6aeae3b2a75f0"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a8c763e890bb00479a6a6aeae3b2a75f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8c763e890bb00479a6a6aeae3b2a75f0">operator&lt;=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8c763e890bb00479a6a6aeae3b2a75f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#a8c763e890bb00479a6a6aeae3b2a75f0">More...</a><br /></td></tr>
<tr class="separator:a8c763e890bb00479a6a6aeae3b2a75f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8131af000055ceab85646c14f234ad"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:aec8131af000055ceab85646c14f234ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aec8131af000055ceab85646c14f234ad">operator&gt;</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aec8131af000055ceab85646c14f234ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#aec8131af000055ceab85646c14f234ad">More...</a><br /></td></tr>
<tr class="separator:aec8131af000055ceab85646c14f234ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb88dfb4278df554e7ffec5361ece4"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:adadb88dfb4278df554e7ffec5361ece4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adadb88dfb4278df554e7ffec5361ece4">operator&gt;=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:adadb88dfb4278df554e7ffec5361ece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#adadb88dfb4278df554e7ffec5361ece4">More...</a><br /></td></tr>
<tr class="separator:adadb88dfb4278df554e7ffec5361ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5ebc5e9d0e87c18a22a72d2261bdf5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">hashed_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6d5ebc5e9d0e87c18a22a72d2261bdf5">operator&quot;&quot;_hs</a> (const char *str, std::size_t) noexcept</td></tr>
<tr class="memdesc:a6d5ebc5e9d0e87c18a22a72d2261bdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed strings.  <a href="namespaceentt.html#a6d5ebc5e9d0e87c18a22a72d2261bdf5">More...</a><br /></td></tr>
<tr class="separator:a6d5ebc5e9d0e87c18a22a72d2261bdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa5b29e7184fb8fe184417411792290"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">hashed_wstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6fa5b29e7184fb8fe184417411792290">operator&quot;&quot;_hws</a> (const wchar_t *str, std::size_t) noexcept</td></tr>
<tr class="memdesc:a6fa5b29e7184fb8fe184417411792290"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed wstrings.  <a href="namespaceentt.html#a6fa5b29e7184fb8fe184417411792290">More...</a><br /></td></tr>
<tr class="separator:a6fa5b29e7184fb8fe184417411792290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4423ccae6f6edef721acf6624b8cec41"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a4423ccae6f6edef721acf6624b8cec41"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4423ccae6f6edef721acf6624b8cec41">operator==</a> (const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;lhs, const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4423ccae6f6edef721acf6624b8cec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespaceentt.html#a4423ccae6f6edef721acf6624b8cec41">More...</a><br /></td></tr>
<tr class="separator:a4423ccae6f6edef721acf6624b8cec41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ee8e2a3f32a371b44e579ef0d0f25"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a883ee8e2a3f32a371b44e579ef0d0f25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a883ee8e2a3f32a371b44e579ef0d0f25">operator!=</a> (const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;lhs, const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a883ee8e2a3f32a371b44e579ef0d0f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="namespaceentt.html#a883ee8e2a3f32a371b44e579ef0d0f25">More...</a><br /></td></tr>
<tr class="separator:a883ee8e2a3f32a371b44e579ef0d0f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ae1b5fdbd6563ea136dcd40ed714ad"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a62ae1b5fdbd6563ea136dcd40ed714ad">is_power_of_two</a> (const std::size_t value) noexcept</td></tr>
<tr class="memdesc:a62ae1b5fdbd6563ea136dcd40ed714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a value is a power of two or not.  <a href="namespaceentt.html#a62ae1b5fdbd6563ea136dcd40ed714ad">More...</a><br /></td></tr>
<tr class="separator:a62ae1b5fdbd6563ea136dcd40ed714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b95d19a5709187e6906a5a9c407b55"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac0b95d19a5709187e6906a5a9c407b55">next_power_of_two</a> (const std::size_t value) noexcept</td></tr>
<tr class="memdesc:ac0b95d19a5709187e6906a5a9c407b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest power of two greater than or equal to a value.  <a href="namespaceentt.html#ac0b95d19a5709187e6906a5a9c407b55">More...</a><br /></td></tr>
<tr class="separator:ac0b95d19a5709187e6906a5a9c407b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc8848a1cfd5f84991f3932894a20fc"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8bc8848a1cfd5f84991f3932894a20fc">fast_mod</a> (const std::size_t value, const std::size_t mod) noexcept</td></tr>
<tr class="memdesc:a8bc8848a1cfd5f84991f3932894a20fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast module utility function (powers of two only).  <a href="namespaceentt.html#a8bc8848a1cfd5f84991f3932894a20fc">More...</a><br /></td></tr>
<tr class="separator:a8bc8848a1cfd5f84991f3932894a20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ecb90b45a53e3272d761c237a0d850"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:af0ecb90b45a53e3272d761c237a0d850"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af0ecb90b45a53e3272d761c237a0d850">to_address</a> (Type &amp;&amp;ptr) noexcept</td></tr>
<tr class="memdesc:af0ecb90b45a53e3272d761c237a0d850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps fancy pointers, does nothing otherwise (waiting for C++20).  <a href="namespaceentt.html#af0ecb90b45a53e3272d761c237a0d850">More...</a><br /></td></tr>
<tr class="separator:af0ecb90b45a53e3272d761c237a0d850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae934980252d1f2ce8f2473c8d74347df"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:ae934980252d1f2ce8f2473c8d74347df"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae934980252d1f2ce8f2473c8d74347df">propagate_on_container_copy_assignment</a> (Allocator &amp;lhs, Allocator &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae934980252d1f2ce8f2473c8d74347df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <a href="namespaceentt.html#ae934980252d1f2ce8f2473c8d74347df">More...</a><br /></td></tr>
<tr class="separator:ae934980252d1f2ce8f2473c8d74347df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cd263b358a2d495d4f4ee27d4537d7"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a46cd263b358a2d495d4f4ee27d4537d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a46cd263b358a2d495d4f4ee27d4537d7">propagate_on_container_move_assignment</a> (Allocator &amp;lhs, Allocator &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a46cd263b358a2d495d4f4ee27d4537d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <a href="namespaceentt.html#a46cd263b358a2d495d4f4ee27d4537d7">More...</a><br /></td></tr>
<tr class="separator:a46cd263b358a2d495d4f4ee27d4537d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd7ed3d3f11933cd542d8f4646cd695"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a0dd7ed3d3f11933cd542d8f4646cd695"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0dd7ed3d3f11933cd542d8f4646cd695">propagate_on_container_swap</a> (Allocator &amp;lhs, Allocator &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0dd7ed3d3f11933cd542d8f4646cd695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <a href="namespaceentt.html#a0dd7ed3d3f11933cd542d8f4646cd695">More...</a><br /></td></tr>
<tr class="separator:a0dd7ed3d3f11933cd542d8f4646cd695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3729f1b7699d013f982b2de2ec781f9"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Allocator , typename... Args&gt; </td></tr>
<tr class="memitem:ae3729f1b7699d013f982b2de2ec781f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae3729f1b7699d013f982b2de2ec781f9">allocate_unique</a> (Allocator &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae3729f1b7699d013f982b2de2ec781f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows <code>std::unique_ptr</code> to use allocators (waiting for C++20).  <a href="namespaceentt.html#ae3729f1b7699d013f982b2de2ec781f9">More...</a><br /></td></tr>
<tr class="separator:ae3729f1b7699d013f982b2de2ec781f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac447ddab9d528647a79fd9aca429faed"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Allocator , typename... Args&gt; </td></tr>
<tr class="memitem:ac447ddab9d528647a79fd9aca429faed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac447ddab9d528647a79fd9aca429faed">uses_allocator_construction_args</a> (const Allocator &amp;allocator, Args &amp;&amp;...args) noexcept</td></tr>
<tr class="memdesc:ac447ddab9d528647a79fd9aca429faed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses-allocator construction utility (waiting for C++20).  <a href="namespaceentt.html#ac447ddab9d528647a79fd9aca429faed">More...</a><br /></td></tr>
<tr class="separator:ac447ddab9d528647a79fd9aca429faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Allocator , typename... Args&gt; </td></tr>
<tr class="memitem:a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a12e4d0c58f9c4cc6f5513c39c530b9b7">make_obj_using_allocator</a> (const Allocator &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses-allocator construction utility (waiting for C++20).  <a href="namespaceentt.html#a12e4d0c58f9c4cc6f5513c39c530b9b7">More...</a><br /></td></tr>
<tr class="separator:a12e4d0c58f9c4cc6f5513c39c530b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f946567d220e7c8814636333d0cbe0"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Allocator , typename... Args&gt; </td></tr>
<tr class="memitem:a81f946567d220e7c8814636333d0cbe0"><td class="memTemplItemLeft" align="right" valign="top">constexpr Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a81f946567d220e7c8814636333d0cbe0">uninitialized_construct_using_allocator</a> (Type *value, const Allocator &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a81f946567d220e7c8814636333d0cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses-allocator construction utility (waiting for C++20).  <a href="namespaceentt.html#a81f946567d220e7c8814636333d0cbe0">More...</a><br /></td></tr>
<tr class="separator:a81f946567d220e7c8814636333d0cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2665e41871f7493f674c8dbba0a593"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:abf2665e41871f7493f674c8dbba0a593"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abf2665e41871f7493f674c8dbba0a593">unwrap_tuple</a> (Type &amp;&amp;value) noexcept</td></tr>
<tr class="memdesc:abf2665e41871f7493f674c8dbba0a593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to unwrap tuples of a single element.  <a href="namespaceentt.html#abf2665e41871f7493f674c8dbba0a593">More...</a><br /></td></tr>
<tr class="separator:abf2665e41871f7493f674c8dbba0a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0662ddd2021dbf1513b7d0b40c50b9b2">forward_apply</a> (Func) -&gt; <a class="el" href="structentt_1_1forward__apply.html">forward_apply</a>&lt; std::remove_reference_t&lt; std::remove_cv_t&lt; Func &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a0662ddd2021dbf1513b7d0b40c50b9b2">More...</a><br /></td></tr>
<tr class="separator:a0662ddd2021dbf1513b7d0b40c50b9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcf4803e990dfe0867025bf76de501c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2dcf4803e990dfe0867025bf76de501c">operator==</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2dcf4803e990dfe0867025bf76de501c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <a href="namespaceentt.html#a2dcf4803e990dfe0867025bf76de501c">More...</a><br /></td></tr>
<tr class="separator:a2dcf4803e990dfe0867025bf76de501c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4410448e22ae52de3bcbf262be9030"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afe4410448e22ae52de3bcbf262be9030">operator!=</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:afe4410448e22ae52de3bcbf262be9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <a href="namespaceentt.html#afe4410448e22ae52de3bcbf262be9030">More...</a><br /></td></tr>
<tr class="separator:afe4410448e22ae52de3bcbf262be9030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6216409945594d3a50e9b8d3ad72f7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5f6216409945594d3a50e9b8d3ad72f7">operator&lt;</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5f6216409945594d3a50e9b8d3ad72f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#a5f6216409945594d3a50e9b8d3ad72f7">More...</a><br /></td></tr>
<tr class="separator:a5f6216409945594d3a50e9b8d3ad72f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce5a8a6786a787daa1a656f221158cf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#acce5a8a6786a787daa1a656f221158cf">operator&lt;=</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acce5a8a6786a787daa1a656f221158cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#acce5a8a6786a787daa1a656f221158cf">More...</a><br /></td></tr>
<tr class="separator:acce5a8a6786a787daa1a656f221158cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8ef328173f0b43d96f8d042d7f444"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abad8ef328173f0b43d96f8d042d7f444">operator&gt;</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:abad8ef328173f0b43d96f8d042d7f444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#abad8ef328173f0b43d96f8d042d7f444">More...</a><br /></td></tr>
<tr class="separator:abad8ef328173f0b43d96f8d042d7f444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502743d6a5b36ceff050779d93b444ca"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a502743d6a5b36ceff050779d93b444ca">operator&gt;=</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a502743d6a5b36ceff050779d93b444ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#a502743d6a5b36ceff050779d93b444ca">More...</a><br /></td></tr>
<tr class="separator:a502743d6a5b36ceff050779d93b444ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9682d476edbbe4434680363f9c0eb3"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:adb9682d476edbbe4434680363f9c0eb3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adb9682d476edbbe4434680363f9c0eb3">type_id</a> () noexcept</td></tr>
<tr class="memdesc:adb9682d476edbbe4434680363f9c0eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info object associated to a given type.  <a href="namespaceentt.html#adb9682d476edbbe4434680363f9c0eb3">More...</a><br /></td></tr>
<tr class="separator:adb9682d476edbbe4434680363f9c0eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17387091b8374f89bfd73b2630768b53"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a17387091b8374f89bfd73b2630768b53"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a17387091b8374f89bfd73b2630768b53">type_id</a> (Type &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:a17387091b8374f89bfd73b2630768b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info object associated to a given type.  <a href="namespaceentt.html#a17387091b8374f89bfd73b2630768b53">More...</a><br /></td></tr>
<tr class="separator:a17387091b8374f89bfd73b2630768b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36ceb26049f62c07817a385e35395f6"><td class="memTemplParams" colspan="2">template&lt;typename... Type, typename... Other&gt; </td></tr>
<tr class="memitem:ab36ceb26049f62c07817a385e35395f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab36ceb26049f62c07817a385e35395f6">operator+</a> (<a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;, <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:ab36ceb26049f62c07817a385e35395f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="namespaceentt.html#ab36ceb26049f62c07817a385e35395f6">More...</a><br /></td></tr>
<tr class="separator:ab36ceb26049f62c07817a385e35395f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64074f983c827563bdd5cf7d5dde"><td class="memTemplParams" colspan="2">template&lt;auto... Value, auto... Other&gt; </td></tr>
<tr class="memitem:a722a64074f983c827563bdd5cf7d5dde"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a722a64074f983c827563bdd5cf7d5dde">operator+</a> (<a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;, <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:a722a64074f983c827563bdd5cf7d5dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="namespaceentt.html#a722a64074f983c827563bdd5cf7d5dde">More...</a><br /></td></tr>
<tr class="separator:a722a64074f983c827563bdd5cf7d5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5131df9ce458a6884c43595f501f916"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Class &gt; </td></tr>
<tr class="memitem:ac5131df9ce458a6884c43595f501f916"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac5131df9ce458a6884c43595f501f916">overload</a> (Type Class::*member) noexcept</td></tr>
<tr class="memdesc:ac5131df9ce458a6884c43595f501f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded members of a class.  <a href="namespaceentt.html#ac5131df9ce458a6884c43595f501f916">More...</a><br /></td></tr>
<tr class="separator:ac5131df9ce458a6884c43595f501f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a267f6d6d3ea49bd36f7e8d2f002ec1d1">overload</a> (Func *func) noexcept</td></tr>
<tr class="memdesc:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded functions.  <a href="namespaceentt.html#a267f6d6d3ea49bd36f7e8d2f002ec1d1">More...</a><br /></td></tr>
<tr class="separator:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplParams" colspan="2">template&lt;class... Func&gt; </td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">overloaded</a> (Func...) -&gt; <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td></tr>
<tr class="memdesc:a26eb67ac302229374c5fb623d529f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">More...</a><br /></td></tr>
<tr class="separator:a26eb67ac302229374c5fb623d529f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad2e252dbd8c8ebd486a3d84fbf8c2602">to_integral</a> (const Entity value) noexcept</td></tr>
<tr class="memdesc:ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an entity to its underlying type.  <a href="namespaceentt.html#ad2e252dbd8c8ebd486a3d84fbf8c2602">More...</a><br /></td></tr>
<tr class="separator:ad2e252dbd8c8ebd486a3d84fbf8c2602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202b4027d32db124efffdf1f2f8c5a2"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a1202b4027d32db124efffdf1f2f8c5a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1202b4027d32db124efffdf1f2f8c5a2">to_entity</a> (const Entity value) noexcept</td></tr>
<tr class="memdesc:a1202b4027d32db124efffdf1f2f8c5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity part once converted to the underlying type.  <a href="namespaceentt.html#a1202b4027d32db124efffdf1f2f8c5a2">More...</a><br /></td></tr>
<tr class="separator:a1202b4027d32db124efffdf1f2f8c5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d8995ec3448ce5151309ef2281d33"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a4b7d8995ec3448ce5151309ef2281d33"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::version_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4b7d8995ec3448ce5151309ef2281d33">to_version</a> (const Entity value) noexcept</td></tr>
<tr class="memdesc:a4b7d8995ec3448ce5151309ef2281d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version part once converted to the underlying type.  <a href="namespaceentt.html#a4b7d8995ec3448ce5151309ef2281d33">More...</a><br /></td></tr>
<tr class="separator:a4b7d8995ec3448ce5151309ef2281d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd28fe24ca2b9544e78a296ce43ec2e"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a6bd28fe24ca2b9544e78a296ce43ec2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6bd28fe24ca2b9544e78a296ce43ec2e">operator==</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> other) noexcept</td></tr>
<tr class="memdesc:a6bd28fe24ca2b9544e78a296ce43ec2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an identifier of any type.  <a href="namespaceentt.html#a6bd28fe24ca2b9544e78a296ce43ec2e">More...</a><br /></td></tr>
<tr class="separator:a6bd28fe24ca2b9544e78a296ce43ec2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfb4a52063118617d88ed10c9241cf1"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a0bfb4a52063118617d88ed10c9241cf1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0bfb4a52063118617d88ed10c9241cf1">operator!=</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> other) noexcept</td></tr>
<tr class="memdesc:a0bfb4a52063118617d88ed10c9241cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an identifier of any type.  <a href="namespaceentt.html#a0bfb4a52063118617d88ed10c9241cf1">More...</a><br /></td></tr>
<tr class="separator:a0bfb4a52063118617d88ed10c9241cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067be6e3c78e4d6da28edce305773a0e"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a067be6e3c78e4d6da28edce305773a0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a067be6e3c78e4d6da28edce305773a0e">operator==</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> other) noexcept</td></tr>
<tr class="memdesc:a067be6e3c78e4d6da28edce305773a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an identifier of any type.  <a href="namespaceentt.html#a067be6e3c78e4d6da28edce305773a0e">More...</a><br /></td></tr>
<tr class="separator:a067be6e3c78e4d6da28edce305773a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00032301649c088b76e496ba0d984ab0"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a00032301649c088b76e496ba0d984ab0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a00032301649c088b76e496ba0d984ab0">operator!=</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> other) noexcept</td></tr>
<tr class="memdesc:a00032301649c088b76e496ba0d984ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an identifier of any type.  <a href="namespaceentt.html#a00032301649c088b76e496ba0d984ab0">More...</a><br /></td></tr>
<tr class="separator:a00032301649c088b76e496ba0d984ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf3030e5e15a6249460c9665395be79"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename... Other&gt; </td></tr>
<tr class="memitem:a3bf3030e5e15a6249460c9665395be79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3bf3030e5e15a6249460c9665395be79">operator==</a> (const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3bf3030e5e15a6249460c9665395be79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a3bf3030e5e15a6249460c9665395be79">More...</a><br /></td></tr>
<tr class="separator:a3bf3030e5e15a6249460c9665395be79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7a84015d46560a44cf751eed96cfeb"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename... Other&gt; </td></tr>
<tr class="memitem:a7c7a84015d46560a44cf751eed96cfeb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7c7a84015d46560a44cf751eed96cfeb">operator!=</a> (const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7c7a84015d46560a44cf751eed96cfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a7c7a84015d46560a44cf751eed96cfeb">More...</a><br /></td></tr>
<tr class="separator:a7c7a84015d46560a44cf751eed96cfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Registry  = std::decay_t&lt;nth_argument_t&lt;0u, Member&gt;&gt;&gt; </td></tr>
<tr class="memitem:ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac25eea8903b4a5d58408cc2e9ecb1a2e">invoke</a> (Registry &amp;reg, const typename Registry::entity_type entt)</td></tr>
<tr class="memdesc:ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create a listener that directly invokes a member function.  <a href="namespaceentt.html#ac25eea8903b4a5d58408cc2e9ecb1a2e">More...</a><br /></td></tr>
<tr class="separator:ac25eea8903b4a5d58408cc2e9ecb1a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafe8aa84438fa3781ebd05fb93ddef4"><td class="memTemplParams" colspan="2">template&lt;typename Registry , typename Component &gt; </td></tr>
<tr class="memitem:adafe8aa84438fa3781ebd05fb93ddef4"><td class="memTemplItemLeft" align="right" valign="top">Registry::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adafe8aa84438fa3781ebd05fb93ddef4">to_entity</a> (const Registry &amp;reg, const Component &amp;instance)</td></tr>
<tr class="memdesc:adafe8aa84438fa3781ebd05fb93ddef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity associated with a given component.  <a href="namespaceentt.html#adafe8aa84438fa3781ebd05fb93ddef4">More...</a><br /></td></tr>
<tr class="separator:adafe8aa84438fa3781ebd05fb93ddef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044bc9823cac51816fc5cbcd490478d1"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a044bc9823cac51816fc5cbcd490478d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a044bc9823cac51816fc5cbcd490478d1">basic_view</a> (Type &amp;...<a class="el" href="namespaceentt.html#a5c7ab17a0233eb285971b211e3128249">storage</a>) -&gt; <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">get_t</a>&lt; Type... &gt;, <a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">exclude_t</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a044bc9823cac51816fc5cbcd490478d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a044bc9823cac51816fc5cbcd490478d1">More...</a><br /></td></tr>
<tr class="separator:a044bc9823cac51816fc5cbcd490478d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb84cde1e16efe42ffc9ec956b66b4"><td class="memTemplParams" colspan="2">template&lt;typename... Get, typename... Exclude&gt; </td></tr>
<tr class="memitem:a60bb84cde1e16efe42ffc9ec956b66b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a60bb84cde1e16efe42ffc9ec956b66b4">basic_view</a> (std::tuple&lt; Get &amp;... &gt;, std::tuple&lt; Exclude &amp;... &gt;={}) -&gt; <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">get_t</a>&lt; Get... &gt;, <a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">exclude_t</a>&lt; Exclude... &gt; &gt;</td></tr>
<tr class="memdesc:a60bb84cde1e16efe42ffc9ec956b66b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a60bb84cde1e16efe42ffc9ec956b66b4">More...</a><br /></td></tr>
<tr class="separator:a60bb84cde1e16efe42ffc9ec956b66b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb14d05375b98c803a4f335b9db15e4"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename Writer &gt; </td></tr>
<tr class="memitem:a8eb14d05375b98c803a4f335b9db15e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">dot</a> (std::ostream &amp;out, const Graph &amp;graph, Writer writer)</td></tr>
<tr class="memdesc:a8eb14d05375b98c803a4f335b9db15e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a graph in dot format.  <a href="namespaceentt.html#a8eb14d05375b98c803a4f335b9db15e4">More...</a><br /></td></tr>
<tr class="separator:a8eb14d05375b98c803a4f335b9db15e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725644b580d804e01ac6f65a927469fd"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a725644b580d804e01ac6f65a927469fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a725644b580d804e01ac6f65a927469fd">dot</a> (std::ostream &amp;out, const Graph &amp;graph)</td></tr>
<tr class="memdesc:a725644b580d804e01ac6f65a927469fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a graph in dot format.  <a href="namespaceentt.html#a725644b580d804e01ac6f65a927469fd">More...</a><br /></td></tr>
<tr class="separator:a725644b580d804e01ac6f65a927469fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">dereference_meta_pointer_like</a> (const Type &amp;value)</td></tr>
<tr class="memdesc:a2ab7b51802157a98106f238335fa7503"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL based lookup function for dereferencing meta pointer-like types.  <a href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">More...</a><br /></td></tr>
<tr class="separator:a2ab7b51802157a98106f238335fa7503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2d7c05b6ee08bf9582e2a119dd6cbd8d">meta</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <a href="namespaceentt.html#a2d7c05b6ee08bf9582e2a119dd6cbd8d">More...</a><br /></td></tr>
<tr class="separator:a2d7c05b6ee08bf9582e2a119dd6cbd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78885d25ace657bedd664e3044152f03"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a78885d25ace657bedd664e3044152f03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a78885d25ace657bedd664e3044152f03">meta</a> () noexcept</td></tr>
<tr class="memdesc:a78885d25ace657bedd664e3044152f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <a href="namespaceentt.html#a78885d25ace657bedd664e3044152f03">More...</a><br /></td></tr>
<tr class="separator:a78885d25ace657bedd664e3044152f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a4a3ee0126a16959fcdfe6229fd057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa4a4a3ee0126a16959fcdfe6229fd057">meta_reset</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:aa4a4a3ee0126a16959fcdfe6229fd057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <a href="namespaceentt.html#aa4a4a3ee0126a16959fcdfe6229fd057">More...</a><br /></td></tr>
<tr class="separator:aa4a4a3ee0126a16959fcdfe6229fd057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e4b586c541f816d71ff5c23b1d2a65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af9e4b586c541f816d71ff5c23b1d2a65">meta_reset</a> (const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:af9e4b586c541f816d71ff5c23b1d2a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <a href="namespaceentt.html#af9e4b586c541f816d71ff5c23b1d2a65">More...</a><br /></td></tr>
<tr class="separator:af9e4b586c541f816d71ff5c23b1d2a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3d262b7705ff50f3fb58d2c90b2d6b61">meta_reset</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <a href="namespaceentt.html#a3d262b7705ff50f3fb58d2c90b2d6b61">More...</a><br /></td></tr>
<tr class="separator:a3d262b7705ff50f3fb58d2c90b2d6b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9a45bd7c93035354ec03dc7f196482"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:abe9a45bd7c93035354ec03dc7f196482"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abe9a45bd7c93035354ec03dc7f196482">meta_reset</a> () noexcept</td></tr>
<tr class="memdesc:abe9a45bd7c93035354ec03dc7f196482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <a href="namespaceentt.html#abe9a45bd7c93035354ec03dc7f196482">More...</a><br /></td></tr>
<tr class="separator:abe9a45bd7c93035354ec03dc7f196482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4671352f38341177295442a0d956c9d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4671352f38341177295442a0d956c9d8">meta_reset</a> (<a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a4671352f38341177295442a0d956c9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all meta types.  <a href="namespaceentt.html#a4671352f38341177295442a0d956c9d8">More...</a><br /></td></tr>
<tr class="separator:a4671352f38341177295442a0d956c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0484b50821691e6aacea122481c1e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4a0484b50821691e6aacea122481c1e6">meta_reset</a> () noexcept</td></tr>
<tr class="memdesc:a4a0484b50821691e6aacea122481c1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all meta types.  <a href="namespaceentt.html#a4a0484b50821691e6aacea122481c1e6">More...</a><br /></td></tr>
<tr class="separator:a4a0484b50821691e6aacea122481c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf59d78f99cd7f20904c2129088bfd7e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:abf59d78f99cd7f20904c2129088bfd7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abf59d78f99cd7f20904c2129088bfd7e">forward_as_meta</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, Type &amp;&amp;value)</td></tr>
<tr class="memdesc:abf59d78f99cd7f20904c2129088bfd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <a href="namespaceentt.html#abf59d78f99cd7f20904c2129088bfd7e">More...</a><br /></td></tr>
<tr class="separator:abf59d78f99cd7f20904c2129088bfd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a77c7a5a8ac08bc879abdaa00f920a996">forward_as_meta</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a77c7a5a8ac08bc879abdaa00f920a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <a href="namespaceentt.html#a77c7a5a8ac08bc879abdaa00f920a996">More...</a><br /></td></tr>
<tr class="separator:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b862c2db6e5771fb95d7a7930e9b18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85b862c2db6e5771fb95d7a7930e9b18">operator!=</a> (const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a85b862c2db6e5771fb95d7a7930e9b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two objects refer to the same type.  <a href="namespaceentt.html#a85b862c2db6e5771fb95d7a7930e9b18">More...</a><br /></td></tr>
<tr class="separator:a85b862c2db6e5771fb95d7a7930e9b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86fb3538f9ba64b4695cf45c020458e"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ad86fb3538f9ba64b4695cf45c020458e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad86fb3538f9ba64b4695cf45c020458e">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:ad86fb3538f9ba64b4695cf45c020458e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <a href="namespaceentt.html#ad86fb3538f9ba64b4695cf45c020458e">More...</a><br /></td></tr>
<tr class="separator:ad86fb3538f9ba64b4695cf45c020458e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a9dc2ece8ba5dafc463abdceb1f55eaea">resolve</a> () noexcept</td></tr>
<tr class="memdesc:a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <a href="namespaceentt.html#a9dc2ece8ba5dafc463abdceb1f55eaea">More...</a><br /></td></tr>
<tr class="separator:a9dc2ece8ba5dafc463abdceb1f55eaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894939ee94a38b6843a8d29ab770f36a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceentt.html#a19a0f990ac8ad302430ef72224fb02eb">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a894939ee94a38b6843a8d29ab770f36a">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx) noexcept</td></tr>
<tr class="memdesc:a894939ee94a38b6843a8d29ab770f36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range to use to visit all meta types.  <a href="namespaceentt.html#a894939ee94a38b6843a8d29ab770f36a">More...</a><br /></td></tr>
<tr class="separator:a894939ee94a38b6843a8d29ab770f36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1cf09707283197b9914fa8520e7592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceentt.html#a19a0f990ac8ad302430ef72224fb02eb">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1a1cf09707283197b9914fa8520e7592">resolve</a> () noexcept</td></tr>
<tr class="memdesc:a1a1cf09707283197b9914fa8520e7592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range to use to visit all meta types.  <a href="namespaceentt.html#a1a1cf09707283197b9914fa8520e7592">More...</a><br /></td></tr>
<tr class="separator:a1a1cf09707283197b9914fa8520e7592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669729b83f4e0e2433cbf2a881745e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a669729b83f4e0e2433cbf2a881745e22">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:a669729b83f4e0e2433cbf2a881745e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier, if any.  <a href="namespaceentt.html#a669729b83f4e0e2433cbf2a881745e22">More...</a><br /></td></tr>
<tr class="separator:a669729b83f4e0e2433cbf2a881745e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4493a8ed8dc4bc71b11058973c0fd9aa">resolve</a> (const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier, if any.  <a href="namespaceentt.html#a4493a8ed8dc4bc71b11058973c0fd9aa">More...</a><br /></td></tr>
<tr class="separator:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7072f59c8738e44792806ab65c693032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7072f59c8738e44792806ab65c693032">resolve</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;info) noexcept</td></tr>
<tr class="memdesc:a7072f59c8738e44792806ab65c693032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type info object.  <a href="namespaceentt.html#a7072f59c8738e44792806ab65c693032">More...</a><br /></td></tr>
<tr class="separator:a7072f59c8738e44792806ab65c693032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dcce4d98f6a27c4c61e814466900b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a28dcce4d98f6a27c4c61e814466900b2">resolve</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;info) noexcept</td></tr>
<tr class="memdesc:a28dcce4d98f6a27c4c61e814466900b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type info object.  <a href="namespaceentt.html#a28dcce4d98f6a27c4c61e814466900b2">More...</a><br /></td></tr>
<tr class="separator:a28dcce4d98f6a27c4c61e814466900b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f82832c0a318d045d51e4cdc3f90c7e"><td class="memTemplParams" colspan="2">template&lt;typename Policy  = as_is_t, typename Type &gt; </td></tr>
<tr class="memitem:a8f82832c0a318d045d51e4cdc3f90c7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8f82832c0a318d045d51e4cdc3f90c7e">meta_dispatch</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a8f82832c0a318d045d51e4cdc3f90c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a value depending on the given policy.  <a href="namespaceentt.html#a8f82832c0a318d045d51e4cdc3f90c7e">More...</a><br /></td></tr>
<tr class="separator:a8f82832c0a318d045d51e4cdc3f90c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa0d4c01cb554a8c4ff29154fba457a"><td class="memTemplParams" colspan="2">template&lt;typename Policy  = as_is_t, typename Type &gt; </td></tr>
<tr class="memitem:aefa0d4c01cb554a8c4ff29154fba457a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aefa0d4c01cb554a8c4ff29154fba457a">meta_dispatch</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:aefa0d4c01cb554a8c4ff29154fba457a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a value depending on the given policy.  <a href="namespaceentt.html#aefa0d4c01cb554a8c4ff29154fba457a">More...</a><br /></td></tr>
<tr class="separator:aefa0d4c01cb554a8c4ff29154fba457a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14f35fbe2a40c6a94108b95507517fb"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data&gt; </td></tr>
<tr class="memitem:ac14f35fbe2a40c6a94108b95507517fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac14f35fbe2a40c6a94108b95507517fb">meta_setter</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> value)</td></tr>
<tr class="memdesc:ac14f35fbe2a40c6a94108b95507517fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given variable.  <a href="namespaceentt.html#ac14f35fbe2a40c6a94108b95507517fb">More...</a><br /></td></tr>
<tr class="separator:ac14f35fbe2a40c6a94108b95507517fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa754d1db973d40e40f7b1aa6aebb7ab3">meta_getter</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance)</td></tr>
<tr class="memdesc:aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a given variable.  <a href="namespaceentt.html#aa754d1db973d40e40f7b1aa6aebb7ab3">More...</a><br /></td></tr>
<tr class="separator:aa754d1db973d40e40f7b1aa6aebb7ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492632c2f27d1e0c745d73398ac534d3"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a492632c2f27d1e0c745d73398ac534d3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a492632c2f27d1e0c745d73398ac534d3">meta_getter</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance)</td></tr>
<tr class="memdesc:a492632c2f27d1e0c745d73398ac534d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a given variable.  <a href="namespaceentt.html#a492632c2f27d1e0c745d73398ac534d3">More...</a><br /></td></tr>
<tr class="separator:a492632c2f27d1e0c745d73398ac534d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4a6163636762f35f9e984f1278905f"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </td></tr>
<tr class="memitem:a1f4a6163636762f35f9e984f1278905f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1f4a6163636762f35f9e984f1278905f">meta_invoke</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a1f4a6163636762f35f9e984f1278905f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to <em>invoke</em> an object given a list of erased parameters.  <a href="namespaceentt.html#a1f4a6163636762f35f9e984f1278905f">More...</a><br /></td></tr>
<tr class="separator:a1f4a6163636762f35f9e984f1278905f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8befe85c5ee65562cff4dadac3dc00ef"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </td></tr>
<tr class="memitem:a8befe85c5ee65562cff4dadac3dc00ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8befe85c5ee65562cff4dadac3dc00ef">meta_invoke</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a8befe85c5ee65562cff4dadac3dc00ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to <em>invoke</em> an object given a list of erased parameters.  <a href="namespaceentt.html#a8befe85c5ee65562cff4dadac3dc00ef">More...</a><br /></td></tr>
<tr class="separator:a8befe85c5ee65562cff4dadac3dc00ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a3b88b27196cb423e5d45eada1348"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:ac23a3b88b27196cb423e5d45eada1348"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac23a3b88b27196cb423e5d45eada1348">meta_invoke</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:ac23a3b88b27196cb423e5d45eada1348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to invoke a function given a list of erased parameters.  <a href="namespaceentt.html#ac23a3b88b27196cb423e5d45eada1348">More...</a><br /></td></tr>
<tr class="separator:ac23a3b88b27196cb423e5d45eada1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1b2e11225caa53d5880e81915e9316"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:aef1b2e11225caa53d5880e81915e9316"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aef1b2e11225caa53d5880e81915e9316">meta_invoke</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:aef1b2e11225caa53d5880e81915e9316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to invoke a function given a list of erased parameters.  <a href="namespaceentt.html#aef1b2e11225caa53d5880e81915e9316">More...</a><br /></td></tr>
<tr class="separator:aef1b2e11225caa53d5880e81915e9316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571cc8688ebf018c16e2a15f6c45764a"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:a571cc8688ebf018c16e2a15f6c45764a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a571cc8688ebf018c16e2a15f6c45764a">meta_construct</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a571cc8688ebf018c16e2a15f6c45764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a571cc8688ebf018c16e2a15f6c45764a">More...</a><br /></td></tr>
<tr class="separator:a571cc8688ebf018c16e2a15f6c45764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0d075524517183181aa512417358a0"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:a3b0d075524517183181aa512417358a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3b0d075524517183181aa512417358a0">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a3b0d075524517183181aa512417358a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a3b0d075524517183181aa512417358a0">More...</a><br /></td></tr>
<tr class="separator:a3b0d075524517183181aa512417358a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d052556804c409d65dcf2985dc44e2"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </td></tr>
<tr class="memitem:a21d052556804c409d65dcf2985dc44e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a21d052556804c409d65dcf2985dc44e2">meta_construct</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a21d052556804c409d65dcf2985dc44e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a21d052556804c409d65dcf2985dc44e2">More...</a><br /></td></tr>
<tr class="separator:a21d052556804c409d65dcf2985dc44e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba2afbd0762cd23f85df6d65d6a8413"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </td></tr>
<tr class="memitem:a7ba2afbd0762cd23f85df6d65d6a8413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7ba2afbd0762cd23f85df6d65d6a8413">meta_construct</a> (Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a7ba2afbd0762cd23f85df6d65d6a8413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a7ba2afbd0762cd23f85df6d65d6a8413">More...</a><br /></td></tr>
<tr class="separator:a7ba2afbd0762cd23f85df6d65d6a8413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7f1ee2282bd9da8ef9a8b1f2c49c431b">meta_construct</a> (const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;ctx, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a7f1ee2282bd9da8ef9a8b1f2c49c431b">More...</a><br /></td></tr>
<tr class="separator:a7f1ee2282bd9da8ef9a8b1f2c49c431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbe3810e19337b32c66c6bab769338a"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a5fbe3810e19337b32c66c6bab769338a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5fbe3810e19337b32c66c6bab769338a">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a5fbe3810e19337b32c66c6bab769338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a5fbe3810e19337b32c66c6bab769338a">More...</a><br /></td></tr>
<tr class="separator:a5fbe3810e19337b32c66c6bab769338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memTemplParams" colspan="2">template&lt;std::size_t Member, typename Poly , typename... Args&gt; </td></tr>
<tr class="memitem:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8b4f2adf317a555138ef5c1cf45b034a">poly_call</a> (Poly &amp;&amp;self, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a8b4f2adf317a555138ef5c1cf45b034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;::invoke</code>.  <a href="namespaceentt.html#a8b4f2adf317a555138ef5c1cf45b034a">More...</a><br /></td></tr>
<tr class="separator:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8673e2cd084833ef799c2b5e762d44d2"><td class="memTemplParams" colspan="2">template&lt;typename Res , typename Other &gt; </td></tr>
<tr class="memitem:a8673e2cd084833ef799c2b5e762d44d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8673e2cd084833ef799c2b5e762d44d2">operator==</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8673e2cd084833ef799c2b5e762d44d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a8673e2cd084833ef799c2b5e762d44d2">More...</a><br /></td></tr>
<tr class="separator:a8673e2cd084833ef799c2b5e762d44d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5abcbaafb983f804bef4fc83b58430e"><td class="memTemplParams" colspan="2">template&lt;typename Res , typename Other &gt; </td></tr>
<tr class="memitem:ab5abcbaafb983f804bef4fc83b58430e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab5abcbaafb983f804bef4fc83b58430e">operator!=</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab5abcbaafb983f804bef4fc83b58430e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#ab5abcbaafb983f804bef4fc83b58430e">More...</a><br /></td></tr>
<tr class="separator:ab5abcbaafb983f804bef4fc83b58430e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b29de0b43cc9ec62b8c0c194e3d9c44"><td class="memTemplParams" colspan="2">template&lt;typename Res , typename Other &gt; </td></tr>
<tr class="memitem:a6b29de0b43cc9ec62b8c0c194e3d9c44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6b29de0b43cc9ec62b8c0c194e3d9c44">operator&lt;</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a6b29de0b43cc9ec62b8c0c194e3d9c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a6b29de0b43cc9ec62b8c0c194e3d9c44">More...</a><br /></td></tr>
<tr class="separator:a6b29de0b43cc9ec62b8c0c194e3d9c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c1f2e85a177861238ecc356f053f68"><td class="memTemplParams" colspan="2">template&lt;typename Res , typename Other &gt; </td></tr>
<tr class="memitem:a85c1f2e85a177861238ecc356f053f68"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85c1f2e85a177861238ecc356f053f68">operator&gt;</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a85c1f2e85a177861238ecc356f053f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a85c1f2e85a177861238ecc356f053f68">More...</a><br /></td></tr>
<tr class="separator:a85c1f2e85a177861238ecc356f053f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae550c1310de77e009f6796229c67b1d7"><td class="memTemplParams" colspan="2">template&lt;typename Res , typename Other &gt; </td></tr>
<tr class="memitem:ae550c1310de77e009f6796229c67b1d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae550c1310de77e009f6796229c67b1d7">operator&lt;=</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae550c1310de77e009f6796229c67b1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#ae550c1310de77e009f6796229c67b1d7">More...</a><br /></td></tr>
<tr class="separator:ae550c1310de77e009f6796229c67b1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924a2fdb5e4c0c06546cda243b30d1e4"><td class="memTemplParams" colspan="2">template&lt;typename Res , typename Other &gt; </td></tr>
<tr class="memitem:a924a2fdb5e4c0c06546cda243b30d1e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a924a2fdb5e4c0c06546cda243b30d1e4">operator&gt;=</a> (const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;lhs, const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a924a2fdb5e4c0c06546cda243b30d1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a924a2fdb5e4c0c06546cda243b30d1e4">More...</a><br /></td></tr>
<tr class="separator:a924a2fdb5e4c0c06546cda243b30d1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663976796b773780f6136606c1a3f31"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:ae663976796b773780f6136606c1a3f31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae663976796b773780f6136606c1a3f31">operator!=</a> (const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;lhs, const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae663976796b773780f6136606c1a3f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two delegates.  <a href="namespaceentt.html#ae663976796b773780f6136606c1a3f31">More...</a><br /></td></tr>
<tr class="separator:ae663976796b773780f6136606c1a3f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa5569564e913ef41b15b06e3dca0f4"><td class="memTemplParams" colspan="2">template&lt;auto Candidate&gt; </td></tr>
<tr class="memitem:acaa5569564e913ef41b15b06e3dca0f4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#acaa5569564e913ef41b15b06e3dca0f4">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt; &gt; &gt;</td></tr>
<tr class="memdesc:acaa5569564e913ef41b15b06e3dca0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#acaa5569564e913ef41b15b06e3dca0f4">More...</a><br /></td></tr>
<tr class="separator:acaa5569564e913ef41b15b06e3dca0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af883efa5bf613137f825c322df3ae801"><td class="memTemplParams" colspan="2">template&lt;auto Candidate, typename Type &gt; </td></tr>
<tr class="memitem:af883efa5bf613137f825c322df3ae801"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af883efa5bf613137f825c322df3ae801">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;, Type &amp;&amp;) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt; &gt; &gt;</td></tr>
<tr class="memdesc:af883efa5bf613137f825c322df3ae801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#af883efa5bf613137f825c322df3ae801">More...</a><br /></td></tr>
<tr class="separator:af883efa5bf613137f825c322df3ae801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaba06006a862fa5dc613e8561ac4e92c">delegate</a> (Ret(*)(const void *, Args...), const void *=nullptr) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:aaba06006a862fa5dc613e8561ac4e92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aaba06006a862fa5dc613e8561ac4e92c">More...</a><br /></td></tr>
<tr class="separator:aaba06006a862fa5dc613e8561ac4e92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd935c76f0b7bf40958ec43565ea157"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args, typename Allocator &gt; </td></tr>
<tr class="memitem:aebd935c76f0b7bf40958ec43565ea157"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aebd935c76f0b7bf40958ec43565ea157">sink</a> (<a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &amp;) -&gt; <a class="el" href="classentt_1_1sink.html">sink</a>&lt; <a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &gt;</td></tr>
<tr class="memdesc:aebd935c76f0b7bf40958ec43565ea157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aebd935c76f0b7bf40958ec43565ea157">More...</a><br /></td></tr>
<tr class="separator:aebd935c76f0b7bf40958ec43565ea157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8378b9330b5c90b6b11deee3637ebca6"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a8378b9330b5c90b6b11deee3637ebca6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8378b9330b5c90b6b11deee3637ebca6">enum_as_bitmask_v</a> = <a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8378b9330b5c90b6b11deee3637ebca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a8378b9330b5c90b6b11deee3637ebca6">More...</a><br /></td></tr>
<tr class="separator:a8378b9330b5c90b6b11deee3637ebca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> Value&gt; </td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">monostate_v</a> = {}</td></tr>
<tr class="memdesc:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">More...</a><br /></td></tr>
<tr class="separator:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0617c69b8aa01b123162d23d7213c6aa"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0617c69b8aa01b123162d23d7213c6aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0617c69b8aa01b123162d23d7213c6aa">is_tuple_v</a> = <a class="el" href="structentt_1_1is__tuple.html">is_tuple</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a0617c69b8aa01b123162d23d7213c6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a0617c69b8aa01b123162d23d7213c6aa">More...</a><br /></td></tr>
<tr class="separator:a0617c69b8aa01b123162d23d7213c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">choice</a> {}</td></tr>
<tr class="memdesc:a089f75043b082abca3ea144bce44e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for the choice trick.  <a href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">More...</a><br /></td></tr>
<tr class="separator:a089f75043b082abca3ea144bce44e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a15f9a70cbdd5a64f897a012ab2b5834f">size_of_v</a> = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a15f9a70cbdd5a64f897a012ab2b5834f">More...</a><br /></td></tr>
<tr class="separator:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7558c4e09ee416fb7fa3576737ff65"><td class="memTemplParams" colspan="2">template&lt;auto Value, typename &gt; </td></tr>
<tr class="memitem:aee7558c4e09ee416fb7fa3576737ff65"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aee7558c4e09ee416fb7fa3576737ff65">unpack_as_value</a> = Value</td></tr>
<tr class="memdesc:aee7558c4e09ee416fb7fa3576737ff65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#aee7558c4e09ee416fb7fa3576737ff65">More...</a><br /></td></tr>
<tr class="separator:aee7558c4e09ee416fb7fa3576737ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9e46d106b526d281a35901da1edea6"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename List &gt; </td></tr>
<tr class="memitem:a3a9e46d106b526d281a35901da1edea6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3a9e46d106b526d281a35901da1edea6">type_list_index_v</a> = <a class="el" href="structentt_1_1type__list__index.html">type_list_index</a>&lt;Type, List&gt;::value</td></tr>
<tr class="memdesc:a3a9e46d106b526d281a35901da1edea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a3a9e46d106b526d281a35901da1edea6">More...</a><br /></td></tr>
<tr class="separator:a3a9e46d106b526d281a35901da1edea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c"><td class="memTemplParams" colspan="2">template&lt;typename List , typename Type &gt; </td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a988ce063936d499bf2d69406c391fd5c">type_list_contains_v</a> = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td></tr>
<tr class="memdesc:a988ce063936d499bf2d69406c391fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a988ce063936d499bf2d69406c391fd5c">More...</a><br /></td></tr>
<tr class="separator:a988ce063936d499bf2d69406c391fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">value_list_element_v</a> = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td></tr>
<tr class="memdesc:a4bbfb162708696f9c1497d61573b540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">More...</a><br /></td></tr>
<tr class="separator:a4bbfb162708696f9c1497d61573b540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Args &gt; </td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4f238620469de3ef2bafdb28fe4657ef">is_applicable_v</a> = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td></tr>
<tr class="memdesc:a4f238620469de3ef2bafdb28fe4657ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a4f238620469de3ef2bafdb28fe4657ef">More...</a><br /></td></tr>
<tr class="separator:a4f238620469de3ef2bafdb28fe4657ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Func , typename Args &gt; </td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae764716fab8c01b12d3e209004b62647">is_applicable_r_v</a> = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td></tr>
<tr class="memdesc:ae764716fab8c01b12d3e209004b62647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ae764716fab8c01b12d3e209004b62647">More...</a><br /></td></tr>
<tr class="separator:ae764716fab8c01b12d3e209004b62647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">is_complete_v</a> = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">More...</a><br /></td></tr>
<tr class="separator:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3ac133ddb24ec535a11baf3143d188d6">is_iterator_v</a> = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a3ac133ddb24ec535a11baf3143d188d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a3ac133ddb24ec535a11baf3143d188d6">More...</a><br /></td></tr>
<tr class="separator:a3ac133ddb24ec535a11baf3143d188d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b1446d23f1cba20563114f5da1f9d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:afb5b1446d23f1cba20563114f5da1f9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afb5b1446d23f1cba20563114f5da1f9d">is_ebco_eligible_v</a> = <a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:afb5b1446d23f1cba20563114f5da1f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#afb5b1446d23f1cba20563114f5da1f9d">More...</a><br /></td></tr>
<tr class="separator:afb5b1446d23f1cba20563114f5da1f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd3998d86cc531f800d0104478771f4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a5fd3998d86cc531f800d0104478771f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5fd3998d86cc531f800d0104478771f4">is_transparent_v</a> = <a class="el" href="structentt_1_1is__transparent.html">is_transparent</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a5fd3998d86cc531f800d0104478771f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a5fd3998d86cc531f800d0104478771f4">More...</a><br /></td></tr>
<tr class="separator:a5fd3998d86cc531f800d0104478771f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a068dd98a70c771935d2bf3dd96dbad6d">is_equality_comparable_v</a> = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a068dd98a70c771935d2bf3dd96dbad6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a068dd98a70c771935d2bf3dd96dbad6d">More...</a><br /></td></tr>
<tr class="separator:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f9b531ebde614244a0da111d4b66ff"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ab9f9b531ebde614244a0da111d4b66ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab9f9b531ebde614244a0da111d4b66ff">ignore_as_empty_v</a> = (std::is_void_v&lt;Type&gt; || <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt;Type&gt;::page_size == 0u)</td></tr>
<tr class="memdesc:ab9f9b531ebde614244a0da111d4b66ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab9f9b531ebde614244a0da111d4b66ff">More...</a><br /></td></tr>
<tr class="separator:ab9f9b531ebde614244a0da111d4b66ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">null</a> {}</td></tr>
<tr class="memdesc:a2f0c0a1c1d953ea991591748744cdd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for null entities.  <a href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">More...</a><br /></td></tr>
<tr class="separator:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674269102fdfe3fd6d7766210a828862"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a674269102fdfe3fd6d7766210a828862">tombstone</a> {}</td></tr>
<tr class="memdesc:a674269102fdfe3fd6d7766210a828862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for tombstone entities.  <a href="namespaceentt.html#a674269102fdfe3fd6d7766210a828862">More...</a><br /></td></tr>
<tr class="separator:a674269102fdfe3fd6d7766210a828862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">exclude_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">exclude</a> {}</td></tr>
<tr class="memdesc:a5b73210cef43c4db35ef8ce477cc38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for exclusion lists.  <a href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">More...</a><br /></td></tr>
<tr class="separator:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">get_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">get</a> {}</td></tr>
<tr class="memdesc:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of observed components.  <a href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">More...</a><br /></td></tr>
<tr class="separator:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ddbe2446a912714a5fe7251e25768"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:ac91ddbe2446a912714a5fe7251e25768"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#a68dd3ca7c921555e1635fde386d9b243">owned_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac91ddbe2446a912714a5fe7251e25768">owned</a> {}</td></tr>
<tr class="memdesc:ac91ddbe2446a912714a5fe7251e25768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of owned components.  <a href="namespaceentt.html#ac91ddbe2446a912714a5fe7251e25768">More...</a><br /></td></tr>
<tr class="separator:ac91ddbe2446a912714a5fe7251e25768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b073b774362fe800d9cce3542927a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1basic__collector.html">basic_collector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aea8b073b774362fe800d9cce3542927a">collector</a> {}</td></tr>
<tr class="memdesc:aea8b073b774362fe800d9cce3542927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template used to ease the definition of collectors.  <a href="namespaceentt.html#aea8b073b774362fe800d9cce3542927a">More...</a><br /></td></tr>
<tr class="separator:aea8b073b774362fe800d9cce3542927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7148c0f5c0a81e2c48c9d4e52d31f55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1meta__ctx__arg__t.html">meta_ctx_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa7148c0f5c0a81e2c48c9d4e52d31f55">meta_ctx_arg</a> {}</td></tr>
<tr class="memdesc:aa7148c0f5c0a81e2c48c9d4e52d31f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type meta_context_arg_t used to disambiguate calls.  <a href="namespaceentt.html#aa7148c0f5c0a81e2c48c9d4e52d31f55">More...</a><br /></td></tr>
<tr class="separator:aa7148c0f5c0a81e2c48c9d4e52d31f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aeaedca642d9e7220c77c7e1d2855b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a91aeaedca642d9e7220c77c7e1d2855b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a> = <a class="el" href="structentt_1_1is__meta__policy.html">is_meta_policy</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a91aeaedca642d9e7220c77c7e1d2855b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">More...</a><br /></td></tr>
<tr class="separator:a91aeaedca642d9e7220c77c7e1d2855b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">is_meta_pointer_like_v</a> = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aaa8c390cfe71301a0c10f4844e98424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">More...</a><br /></td></tr>
<tr class="separator:aaa8c390cfe71301a0c10f4844e98424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142bebb2be3b87a778b1932b3a267a57"><td class="memTemplParams" colspan="2">template&lt;auto Candidate&gt; </td></tr>
<tr class="memitem:a142bebb2be3b87a778b1932b3a267a57"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a142bebb2be3b87a778b1932b3a267a57">connect_arg</a> {}</td></tr>
<tr class="memdesc:a142bebb2be3b87a778b1932b3a267a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Disambiguation tag for constructors and the like.">connect_arg_t</a> used to disambiguate calls.  <a href="namespaceentt.html#a142bebb2be3b87a778b1932b3a267a57">More...</a><br /></td></tr>
<tr class="separator:a142bebb2be3b87a778b1932b3a267a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><code>EnTT</code> default namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a4846741b8f485584c196304f588b94ad" name="a4846741b8f485584c196304f588b94ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4846741b8f485584c196304f588b94ad">&#9670;&nbsp;</a></span>any</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a4846741b8f485584c196304f588b94ad">entt::any</a> = typedef <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00016">16</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="abbdfab053e66e33baa359f8d48d3d36d" name="abbdfab053e66e33baa359f8d48d3d36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdfab053e66e33baa359f8d48d3d36d">&#9670;&nbsp;</a></span>const_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#abbdfab053e66e33baa359f8d48d3d36d">entt::const_handle</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00124">124</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a45df5147166e6d4b8c60ebb737146d9a" name="a45df5147166e6d4b8c60ebb737146d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45df5147166e6d4b8c60ebb737146d9a">&#9670;&nbsp;</a></span>const_handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a45df5147166e6d4b8c60ebb737146d9a">entt::const_handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00138">138</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a26624baa492b8703941b003545d19519" name="a26624baa492b8703941b003545d19519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26624baa492b8703941b003545d19519">&#9670;&nbsp;</a></span>const_runtime_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a26624baa492b8703941b003545d19519">entt::const_runtime_view</a> = typedef <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt;const <a class="el" href="namespaceentt.html#a2f06dabf02e7aca639b4fa0bb84dc283">sparse_set</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00161">161</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a7b051461867d3c5c97f77f10b662c26b" name="a7b051461867d3c5c97f77f10b662c26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b051461867d3c5c97f77f10b662c26b">&#9670;&nbsp;</a></span>constness_as_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">entt::constness_as_t</a> = typedef typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt;To, From&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the transcription of the constness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to which to transcribe the constness. </td></tr>
    <tr><td class="paramname">From</td><td>The type from which to transcribe the constness. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00693">693</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af8516c2683fa3eed9e5f2e6c63ed8082" name="af8516c2683fa3eed9e5f2e6c63ed8082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8516c2683fa3eed9e5f2e6c63ed8082">&#9670;&nbsp;</a></span>continuous_loader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#af8516c2683fa3eed9e5f2e6c63ed8082">entt::continuous_loader</a> = typedef <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt;<a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00147">147</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a3b9e500ff0298787e120786c6247ba7c" name="a3b9e500ff0298787e120786c6247ba7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9e500ff0298787e120786c6247ba7c">&#9670;&nbsp;</a></span>dispatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a3b9e500ff0298787e120786c6247ba7c">entt::dispatcher</a> = typedef <a class="el" href="classentt_1_1basic__dispatcher.html">basic_dispatcher</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="signal_2fwd_8hpp_source.html#l00028">28</a> of file <a class="el" href="signal_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a806da7d3930a8e5fff66e8f4be841f44" name="a806da7d3930a8e5fff66e8f4be841f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806da7d3930a8e5fff66e8f4be841f44">&#9670;&nbsp;</a></span>exclude_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">entt::exclude_t</a> = typedef <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt;Type...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for exclusion lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00064">64</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a2d5cc1a771624f5b46912cfd5a30bb67" name="a2d5cc1a771624f5b46912cfd5a30bb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5cc1a771624f5b46912cfd5a30bb67">&#9670;&nbsp;</a></span>flow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a2d5cc1a771624f5b46912cfd5a30bb67">entt::flow</a> = typedef <a class="el" href="classentt_1_1basic__flow.html">basic_flow</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="graph_2fwd_8hpp_source.html#l00023">23</a> of file <a class="el" href="graph_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0848971d27a69686665fb953fc62f4df" name="a0848971d27a69686665fb953fc62f4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0848971d27a69686665fb953fc62f4df">&#9670;&nbsp;</a></span>get_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">entt::get_t</a> = typedef <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt;Type...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for lists of observed components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00078">78</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a692d5f7362f72f433e9e7fa0447507dd" name="a692d5f7362f72f433e9e7fa0447507dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692d5f7362f72f433e9e7fa0447507dd">&#9670;&nbsp;</a></span>group</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Owned , typename Get , typename Exclude &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a692d5f7362f72f433e9e7fa0447507dd">entt::group</a> = typedef <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt;<a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt;Owned, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt;Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt;Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Owned</td><td>Types of storage <em>owned</em> by the group. </td></tr>
    <tr><td class="paramname">Get</td><td>Types of storage <em>observed</em> by the group. </td></tr>
    <tr><td class="paramname">Exclude</td><td>Types of storage used to filter the group. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00170">170</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a2482f76c688f8d89f2b3c4cd03bf4be3" name="a2482f76c688f8d89f2b3c4cd03bf4be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2482f76c688f8d89f2b3c4cd03bf4be3">&#9670;&nbsp;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a2482f76c688f8d89f2b3c4cd03bf4be3">entt::handle</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00121">121</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="afba3a637756cc5dce61ba276a6f8e3e6" name="afba3a637756cc5dce61ba276a6f8e3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba3a637756cc5dce61ba276a6f8e3e6">&#9670;&nbsp;</a></span>handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#afba3a637756cc5dce61ba276a6f8e3e6">entt::handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00131">131</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a8f9dd22ce26cd7913a294b3fd520649b" name="a8f9dd22ce26cd7913a294b3fd520649b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9dd22ce26cd7913a294b3fd520649b">&#9670;&nbsp;</a></span>hashed_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">entt::hashed_string</a> = typedef <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aliases for common character types. </p>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00305">305</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="af2768719b1f5967caf5836b2656d0ed6" name="af2768719b1f5967caf5836b2656d0ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2768719b1f5967caf5836b2656d0ed6">&#9670;&nbsp;</a></span>hashed_wstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">entt::hashed_wstring</a> = typedef <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aliases for common character types. </p>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00308">308</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a13e040e7b38a8f86d1ab2f096f37b627" name="a13e040e7b38a8f86d1ab2f096f37b627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e040e7b38a8f86d1ab2f096f37b627">&#9670;&nbsp;</a></span>id_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">entt::id_type</a> = typedef std::uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for type identifiers. </p>

<p class="definition">Definition at line <a class="el" href="core_2fwd_8hpp_source.html#l00013">13</a> of file <a class="el" href="core_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0d9fd5898acf13553bbcf14b99159f4d" name="a0d9fd5898acf13553bbcf14b99159f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9fd5898acf13553bbcf14b99159f4d">&#9670;&nbsp;</a></span>integral_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">entt::integral_constant</a> = typedef std::integral_constant&lt;decltype(Value), Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a static constant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A static constant. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00096">96</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a49f19d031690e5ebfffd6c7a4f6bd364" name="a49f19d031690e5ebfffd6c7a4f6bd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f19d031690e5ebfffd6c7a4f6bd364">&#9670;&nbsp;</a></span>member_class_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Member &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">entt::member_class_t</a> = typedef typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt;Member&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>A pointer to a non-static member object or function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00722">722</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a692beabf853ee0f9dc68beab816a6b27" name="a692beabf853ee0f9dc68beab816a6b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692beabf853ee0f9dc68beab816a6b27">&#9670;&nbsp;</a></span>meta_function_helper_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">entt::meta_function_helper_t</a> = typedef typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt;Type, Candidate&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the meta function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to associate with the reflected type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00149">149</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a19a0f990ac8ad302430ef72224fb02eb" name="a19a0f990ac8ad302430ef72224fb02eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a0f990ac8ad302430ef72224fb02eb">&#9670;&nbsp;</a></span>meta_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a19a0f990ac8ad302430ef72224fb02eb">entt::meta_range</a> = typedef <a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a>&lt;internal::meta_range_iterator&lt;Type, It&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterable range to use to iterate all types of meta objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of meta objects returned. </td></tr>
    <tr><td class="paramname">It</td><td>Type of forward iterator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00146">146</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a id="ae5b51f34944eb75076ee9710c939f4aa" name="ae5b51f34944eb75076ee9710c939f4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b51f34944eb75076ee9710c939f4aa">&#9670;&nbsp;</a></span>nth_argument_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, auto Candidate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ae5b51f34944eb75076ee9710c939f4aa">entt::nth_argument_t</a> = typedef typename <a class="el" href="classentt_1_1nth__argument.html">nth_argument</a>&lt;Index, Candidate&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The index of the argument to extract. </td></tr>
    <tr><td class="paramname">Candidate</td><td>A valid function, member function or data member. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00754">754</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a0a7436015f2d06bbaeeac5ba0519786b" name="a0a7436015f2d06bbaeeac5ba0519786b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7436015f2d06bbaeeac5ba0519786b">&#9670;&nbsp;</a></span>observer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a0a7436015f2d06bbaeeac5ba0519786b">entt::observer</a> = typedef <a class="el" href="classentt_1_1basic__observer.html">basic_observer</a>&lt;<a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00115">115</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ad1035ac7ff12b6a8b59ee9dbdf9e9abc" name="ad1035ac7ff12b6a8b59ee9dbdf9e9abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1035ac7ff12b6a8b59ee9dbdf9e9abc">&#9670;&nbsp;</a></span>organizer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ad1035ac7ff12b6a8b59ee9dbdf9e9abc">entt::organizer</a> = typedef <a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a>&lt;<a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00118">118</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a68dd3ca7c921555e1635fde386d9b243" name="a68dd3ca7c921555e1635fde386d9b243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dd3ca7c921555e1635fde386d9b243">&#9670;&nbsp;</a></span>owned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a68dd3ca7c921555e1635fde386d9b243">entt::owned_t</a> = typedef <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt;Type...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for lists of owned components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00092">92</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a53c6f86f6643c525f654540c3d4c6819" name="a53c6f86f6643c525f654540c3d4c6819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c6f86f6643c525f654540c3d4c6819">&#9670;&nbsp;</a></span>poly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Concept &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a53c6f86f6643c525f654540c3d4c6819">entt::poly</a> = typedef <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt;Concept&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Concept</td><td>Concept descriptor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poly_2fwd_8hpp_source.html#l00016">16</a> of file <a class="el" href="poly_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ac52578c5714150de197f815c62899bce" name="ac52578c5714150de197f815c62899bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52578c5714150de197f815c62899bce">&#9670;&nbsp;</a></span>registry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">entt::registry</a> = typedef <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00112">112</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a4d1433f3effac40f4a6d1b92b89f68e9" name="a4d1433f3effac40f4a6d1b92b89f68e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1433f3effac40f4a6d1b92b89f68e9">&#9670;&nbsp;</a></span>runtime_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a4d1433f3effac40f4a6d1b92b89f68e9">entt::runtime_view</a> = typedef <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt;<a class="el" href="namespaceentt.html#a2f06dabf02e7aca639b4fa0bb84dc283">sparse_set</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00158">158</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a793026b4107ee09e64d9759814db86ff" name="a793026b4107ee09e64d9759814db86ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793026b4107ee09e64d9759814db86ff">&#9670;&nbsp;</a></span>snapshot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a793026b4107ee09e64d9759814db86ff">entt::snapshot</a> = typedef <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt;<a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00141">141</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a7ade3d6bdcf2d53899ab2213a26327ca" name="a7ade3d6bdcf2d53899ab2213a26327ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ade3d6bdcf2d53899ab2213a26327ca">&#9670;&nbsp;</a></span>snapshot_loader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a7ade3d6bdcf2d53899ab2213a26327ca">entt::snapshot_loader</a> = typedef <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt;<a class="el" href="namespaceentt.html#ac52578c5714150de197f815c62899bce">registry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00144">144</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a2f06dabf02e7aca639b4fa0bb84dc283" name="a2f06dabf02e7aca639b4fa0bb84dc283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f06dabf02e7aca639b4fa0bb84dc283">&#9670;&nbsp;</a></span>sparse_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a2f06dabf02e7aca639b4fa0bb84dc283">entt::sparse_set</a> = typedef <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00102">102</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a5c7ab17a0233eb285971b211e3128249" name="a5c7ab17a0233eb285971b211e3128249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7ab17a0233eb285971b211e3128249">&#9670;&nbsp;</a></span>storage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a5c7ab17a0233eb285971b211e3128249">entt::storage</a> = typedef <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt;Type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of objects assigned to the entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00109">109</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a609a0599bbe1da577674a4898f18a35b" name="a609a0599bbe1da577674a4898f18a35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609a0599bbe1da577674a4898f18a35b">&#9670;&nbsp;</a></span>storage_for_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a609a0599bbe1da577674a4898f18a35b">entt::storage_for_t</a> = typedef typename <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Arguments to forward. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00937">937</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="ae2c15d729cd7fd9184864a36e0a49097" name="ae2c15d729cd7fd9184864a36e0a49097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c15d729cd7fd9184864a36e0a49097">&#9670;&nbsp;</a></span>storage_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ae2c15d729cd7fd9184864a36e0a49097">entt::storage_type_t</a> = typedef typename <a class="el" href="structentt_1_1storage__type.html">storage_type</a>&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Arguments to forward. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00918">918</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="a9f7bb8c357f08a01ad9c8dab0ea40c1c" name="a9f7bb8c357f08a01ad9c8dab0ea40c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7bb8c357f08a01ad9c8dab0ea40c1c">&#9670;&nbsp;</a></span>tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">entt::tag</a> = typedef <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt;Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the creation of named values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A constant value at least convertible to <code>id_type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00103">103</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a09f6bd6b4aebc03df720e7e69fdc6643" name="a09f6bd6b4aebc03df720e7e69fdc6643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6bd6b4aebc03df720e7e69fdc6643">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">entt::type_identity_t</a> = typedef typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00053">53</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a546467a3662e9a915d5d519ad565e801" name="a546467a3662e9a915d5d519ad565e801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546467a3662e9a915d5d519ad565e801">&#9670;&nbsp;</a></span>type_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">entt::type_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00251">251</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af2992fc009cb3199b0ef9a86bed2285c" name="af2992fc009cb3199b0ef9a86bed2285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2992fc009cb3199b0ef9a86bed2285c">&#9670;&nbsp;</a></span>type_list_diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">entt::type_list_diff_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists between which to compute the difference. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00330">330</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac839c1a03dba2436791d0056d6d0d1b6" name="ac839c1a03dba2436791d0056d6d0d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac839c1a03dba2436791d0056d6d0d1b6">&#9670;&nbsp;</a></span>type_list_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">entt::type_list_element_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt;Index, List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the type to return. </td></tr>
    <tr><td class="paramname">List</td><td>Type list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00148">148</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4cbdb52103a951e6ff27b40765c52975" name="a4cbdb52103a951e6ff27b40765c52975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbdb52103a951e6ff27b40765c52975">&#9670;&nbsp;</a></span>type_list_transform_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List , template&lt; typename... &gt; class Op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">entt::type_list_transform_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__transform.html">type_list_transform</a>&lt;List, Op&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Op</td><td>Unary operation as template class with a type member named <code>type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00353">353</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a75a277a6037279d65cd3874b46ec7166" name="a75a277a6037279d65cd3874b46ec7166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a277a6037279d65cd3874b46ec7166">&#9670;&nbsp;</a></span>type_list_unique_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">entt::type_list_unique_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00283">283</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ae62c84ccab78132ef356b13e4ff12dfa" name="ae62c84ccab78132ef356b13e4ff12dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62c84ccab78132ef356b13e4ff12dfa">&#9670;&nbsp;</a></span>unpack_as_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ae62c84ccab78132ef356b13e4ff12dfa">entt::unpack_as_type</a> = typedef Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00081">81</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a1344cc62598091397018354e6905e431" name="a1344cc62598091397018354e6905e431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344cc62598091397018354e6905e431">&#9670;&nbsp;</a></span>value_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">entt::value_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00449">449</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4c62599319bf5730fb872b759dbed716" name="a4c62599319bf5730fb872b759dbed716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c62599319bf5730fb872b759dbed716">&#9670;&nbsp;</a></span>view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Get , typename Exclude  = exclude_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a4c62599319bf5730fb872b759dbed716">entt::view</a> = typedef <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt;<a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt;Get, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt;, <a class="el" href="namespaceentt.html#a4cbdb52103a951e6ff27b40765c52975">type_list_transform_t</a>&lt;Exclude, <a class="el" href="structentt_1_1storage__for.html">storage_for</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Get</td><td>Types of storage iterated by the view. </td></tr>
    <tr><td class="paramname">Exclude</td><td>Types of storage used to filter the view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00155">155</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abc4d0fa77fae26e7c01793990996c581" name="abc4d0fa77fae26e7c01793990996c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d0fa77fae26e7c01793990996c581">&#9670;&nbsp;</a></span>deletion_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">entt::deletion_policy</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sparse set deletion policy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708" name="abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708"></a>swap_and_pop&#160;</td><td class="fielddoc"><p >Swap-and-pop deletion policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28" name="abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28"></a>in_place&#160;</td><td class="fielddoc"><p >In-place deletion policy. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00143">143</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a0b54e231d069e8a231e14b223388808a" name="a0b54e231d069e8a231e14b223388808a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b54e231d069e8a231e14b223388808a">&#9670;&nbsp;</a></span>entity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entt::entity</a> : <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00012">12</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae3729f1b7699d013f982b2de2ec781f9" name="ae3729f1b7699d013f982b2de2ec781f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3729f1b7699d013f982b2de2ec781f9">&#9670;&nbsp;</a></span>allocate_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Allocator , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::allocate_unique </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows <code>std::unique_ptr</code> to use allocators (waiting for C++20). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to allocate for and to construct. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized unique pointer with a custom deleter. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00146">146</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a336c64e72007016b8c8dcb7ccc70468f" name="a336c64e72007016b8c8dcb7ccc70468f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336c64e72007016b8c8dcb7ccc70468f">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00448">448</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="abfb671c6d5af5e797eca1fadb1980e72" name="abfb671c6d5af5e797eca1fadb1980e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb671c6d5af5e797eca1fadb1980e72">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00439">439</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="ae0b7dd1eaac2e05f42febf94331e1ac0" name="ae0b7dd1eaac2e05f42febf94331e1ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b7dd1eaac2e05f42febf94331e1ac0">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type * entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00471">471</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="ab5824be13d8a7ef8976f580ab3ffeb2c" name="ab5824be13d8a7ef8976f580ab3ffeb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5824be13d8a7ef8976f580ab3ffeb2c">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00431">431</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="aaabf666ed024f5542f987b8b5a658f64" name="aaabf666ed024f5542f987b8b5a658f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabf666ed024f5542f987b8b5a658f64">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type * entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00464">464</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a2238bd6227a1ee3da75a6d4d224c589e" name="a2238bd6227a1ee3da75a6d4d224c589e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2238bd6227a1ee3da75a6d4d224c589e">&#9670;&nbsp;</a></span>basic_hashed_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__hashed__string.html">entt::basic_hashed_string</a> </td>
          <td>(</td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifier. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the string to hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa97361ef962166a4fc51a582d7c6392" name="aaa97361ef962166a4fc51a582d7c6392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa97361ef962166a4fc51a582d7c6392">&#9670;&nbsp;</a></span>basic_hashed_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__hashed__string.html">entt::basic_hashed_string</a> </td>
          <td>(</td>
          <td class="paramtype">const Char(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[N]</td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of characters of the identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60bb84cde1e16efe42ffc9ec956b66b4" name="a60bb84cde1e16efe42ffc9ec956b66b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bb84cde1e16efe42ffc9ec956b66b4">&#9670;&nbsp;</a></span>basic_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Get, typename... Exclude&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__view.html">entt::basic_view</a> </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Get &amp;... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Exclude &amp;... &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">get_t</a>&lt; Get... &gt;, <a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">exclude_t</a>&lt; Exclude... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Get</td><td>Types of components iterated by the view. </td></tr>
    <tr><td class="paramname">Exclude</td><td>Types of components used to filter the view. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a044bc9823cac51816fc5cbcd490478d1" name="a044bc9823cac51816fc5cbcd490478d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044bc9823cac51816fc5cbcd490478d1">&#9670;&nbsp;</a></span>basic_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__view.html">entt::basic_view</a> </td>
          <td>(</td>
          <td class="paramtype">Type &amp;...&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">get_t</a>&lt; Type... &gt;, <a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">exclude_t</a>&lt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of storage classes used to create the view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>The storage for the types to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd93ac21ff904a1ba357caf8ea40cd7f" name="afd93ac21ff904a1ba357caf8ea40cd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93ac21ff904a1ba357caf8ea40cd7f">&#9670;&nbsp;</a></span>compressed_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Other &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1compressed__pair.html">entt::compressed_pair</a> </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Other &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; std::decay_t&lt; Type &gt;, std::decay_t&lt; Other &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of value to use to initialize the first element. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of value to use to initialize the second element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaa5569564e913ef41b15b06e3dca0f4" name="acaa5569564e913ef41b15b06e3dca0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa5569564e913ef41b15b06e3dca0f4">&#9670;&nbsp;</a></span>delegate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af883efa5bf613137f825c322df3ae801" name="af883efa5bf613137f825c322df3ae801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af883efa5bf613137f825c322df3ae801">&#9670;&nbsp;</a></span>delegate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of class or type of payload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba06006a862fa5dc613e8561ac4e92c" name="aaba06006a862fa5dc613e8561ac4e92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba06006a862fa5dc613e8561ac4e92c">&#9670;&nbsp;</a></span>delegate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype">Ret(*)(const void *, Args...)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab7b51802157a98106f238335fa7503" name="a2ab7b51802157a98106f238335fa7503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab7b51802157a98106f238335fa7503">&#9670;&nbsp;</a></span>dereference_meta_pointer_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::dereference_meta_pointer_like </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADL based lookup function for dereferencing meta pointer-like types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer-like object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned from the dereferenced pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adl__pointer_8hpp_source.html#l00013">13</a> of file <a class="el" href="adl__pointer_8hpp_source.html">adl_pointer.hpp</a>.</p>

</div>
</div>
<a id="a725644b580d804e01ac6f65a927469fd" name="a725644b580d804e01ac6f65a927469fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725644b580d804e01ac6f65a927469fd">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a graph in dot format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>Graph type, valid as long as it exposes edges and vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream. </td></tr>
    <tr><td class="paramname">graph</td><td>The graph to output. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dot_8hpp_source.html#l00052">52</a> of file <a class="el" href="dot_8hpp_source.html">dot.hpp</a>.</p>

</div>
</div>
<a id="a8eb14d05375b98c803a4f335b9db15e4" name="a8eb14d05375b98c803a4f335b9db15e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb14d05375b98c803a4f335b9db15e4">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename Writer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Writer&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a graph in dot format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Graph</td><td>Graph type, valid as long as it exposes edges and vertices. </td></tr>
    <tr><td class="paramname">Writer</td><td>Vertex decorator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream. </td></tr>
    <tr><td class="paramname">graph</td><td>The graph to output. </td></tr>
    <tr><td class="paramname">writer</td><td>Vertex decorator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dot_8hpp_source.html#l00019">19</a> of file <a class="el" href="dot_8hpp_source.html">dot.hpp</a>.</p>

</div>
</div>
<a id="a8bc8848a1cfd5f84991f3932894a20fc" name="a8bc8848a1cfd5f84991f3932894a20fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc8848a1cfd5f84991f3932894a20fc">&#9670;&nbsp;</a></span>fast_mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::fast_mod </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast module utility function (powers of two only). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value for which to calculate the modulus. </td></tr>
    <tr><td class="paramname">mod</td><td><em>Modulus</em>, it must be a power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common remainder. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00045">45</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a0662ddd2021dbf1513b7d0b40c50b9b2" name="a0662ddd2021dbf1513b7d0b40c50b9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0662ddd2021dbf1513b7d0b40c50b9b2">&#9670;&nbsp;</a></span>forward_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1forward__apply.html">entt::forward_apply</a> </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1forward__apply.html">forward_apply</a>&lt; std::remove_reference_t&lt; std::remove_cv_t&lt; Func &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Type of underlying invocable object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af02fa96c663a6706416e47a3a6658328" name="af02fa96c663a6706416e47a3a6658328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02fa96c663a6706416e47a3a6658328">&#9670;&nbsp;</a></span>forward_as_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; entt::forward_as_any </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00504">504</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="abf59d78f99cd7f20904c2129088bfd7e" name="abf59d78f99cd7f20904c2129088bfd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf59d78f99cd7f20904c2129088bfd7e">&#9670;&nbsp;</a></span>forward_as_meta() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::forward_as_meta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00616">616</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a77c7a5a8ac08bc879abdaa00f920a996" name="a77c7a5a8ac08bc879abdaa00f920a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c7a5a8ac08bc879abdaa00f920a996">&#9670;&nbsp;</a></span>forward_as_meta() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::forward_as_meta </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00627">627</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="ac25eea8903b4a5d58408cc2e9ecb1a2e" name="ac25eea8903b4a5d58408cc2e9ecb1a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25eea8903b4a5d58408cc2e9ecb1a2e">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Registry  = std::decay_t&lt;nth_argument_t&lt;0u, Member&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::invoke </td>
          <td>(</td>
          <td class="paramtype">Registry &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Registry::entity_type&#160;</td>
          <td class="paramname"><em>entt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to create a listener that directly invokes a member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Member function to invoke on a component of the given type. </td></tr>
    <tr><td class="paramname">Registry</td><td>Basic registry type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">entt</td><td>Entity from which to get the component. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00107">107</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a62ae1b5fdbd6563ea136dcd40ed714ad" name="a62ae1b5fdbd6563ea136dcd40ed714ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ae1b5fdbd6563ea136dcd40ed714ad">&#9670;&nbsp;</a></span>is_power_of_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a value is a power of two or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value that may or may not be a power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is a power of two, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00019">19</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="adb86dc3145589485c094960a089eb953" name="adb86dc3145589485c094960a089eb953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb86dc3145589485c094960a089eb953">&#9670;&nbsp;</a></span>make_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; entt::make_any </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a wrapper from a given type, passing it all arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to use to initialize the wrapper. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized wrapper for an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00491">491</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a12e4d0c58f9c4cc6f5513c39c530b9b7" name="a12e4d0c58f9c4cc6f5513c39c530b9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e4d0c58f9c4cc6f5513c39c530b9b7">&#9670;&nbsp;</a></span>make_obj_using_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Allocator , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Type entt::make_obj_using_allocator </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses-allocator construction utility (waiting for C++20). </p>
<p >Primarily intended for internal use. Creates an object of a given type by means of uses-allocator construction.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to create. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00264">264</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a78885d25ace657bedd664e3044152f03" name="a78885d25ace657bedd664e3044152f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78885d25ace657bedd664e3044152f03">&#9670;&nbsp;</a></span>meta() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p >This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00553">553</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a2d7c05b6ee08bf9582e2a119dd6cbd8d" name="a2d7c05b6ee08bf9582e2a119dd6cbd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7c05b6ee08bf9582e2a119dd6cbd8d">&#9670;&nbsp;</a></span>meta() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p >This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context into which to construct meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00534">534</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a7ba2afbd0762cd23f85df6d65d6a8413" name="a7ba2afbd0762cd23f85df6d65d6a8413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba2afbd0762cd23f85df6d65d6a8413">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">Candidate &amp;&amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00501">501</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a21d052556804c409d65dcf2985dc44e2" name="a21d052556804c409d65dcf2985dc44e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d052556804c409d65dcf2985dc44e2">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Candidate &amp;&amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00483">483</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a571cc8688ebf018c16e2a15f6c45764a" name="a571cc8688ebf018c16e2a15f6c45764a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571cc8688ebf018c16e2a15f6c45764a">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Actual type of the instance to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments expected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the new instance, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00451">451</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a7f1ee2282bd9da8ef9a8b1f2c49c431b" name="a7f1ee2282bd9da8ef9a8b1f2c49c431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ee2282bd9da8ef9a8b1f2c49c431b">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00520">520</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3b0d075524517183181aa512417358a0" name="a3b0d075524517183181aa512417358a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0d075524517183181aa512417358a0">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Actual type of the instance to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments expected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the new instance, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00463">463</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a5fbe3810e19337b32c66c6bab769338a" name="a5fbe3810e19337b32c66c6bab769338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbe3810e19337b32c66c6bab769338a">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00533">533</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8f82832c0a318d045d51e4cdc3f90c7e" name="a8f82832c0a318d045d51e4cdc3f90c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f82832c0a318d045d51e4cdc3f90c7e">&#9670;&nbsp;</a></span>meta_dispatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy  = as_is_t, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_dispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a value depending on the given policy. </p>
<p >This function always returns a wrapped value in the requested context.<br  />
 Therefore, if the passed value is itself a wrapped object with a different context, it undergoes a rebinding to the requested context.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Type</td><td>Type of value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">value</td><td>Value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00165">165</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aefa0d4c01cb554a8c4ff29154fba457a" name="aefa0d4c01cb554a8c4ff29154fba457a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa0d4c01cb554a8c4ff29154fba457a">&#9670;&nbsp;</a></span>meta_dispatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy  = as_is_t, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_dispatch </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a value depending on the given policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Type</td><td>Type of value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00186">186</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aa754d1db973d40e40f7b1aa6aebb7ab3" name="aa754d1db973d40e40f7b1aa6aebb7ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa754d1db973d40e40f7b1aa6aebb7ab3">&#9670;&nbsp;</a></span>meta_getter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_getter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a given variable. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to get. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the value of the underlying variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00272">272</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a492632c2f27d1e0c745d73398ac534d3" name="a492632c2f27d1e0c745d73398ac534d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492632c2f27d1e0c745d73398ac534d3">&#9670;&nbsp;</a></span>meta_getter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_getter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to get. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the value of the underlying variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00309">309</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a1f4a6163636762f35f9e984f1278905f" name="a1f4a6163636762f35f9e984f1278905f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4a6163636762f35f9e984f1278905f">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Candidate &amp;&amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to <em>invoke</em> an object given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00384">384</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ac23a3b88b27196cb423e5d45eada1348" name="ac23a3b88b27196cb423e5d45eada1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a3b88b27196cb423e5d45eada1348">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to invoke a function given a list of erased parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>The context provided is used only for the return type.<br  />
 It's up to the caller to bind the arguments to the right context(s).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00419">419</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8befe85c5ee65562cff4dadac3dc00ef" name="a8befe85c5ee65562cff4dadac3dc00ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8befe85c5ee65562cff4dadac3dc00ef">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Candidate &amp;&amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to <em>invoke</em> an object given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00399">399</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aef1b2e11225caa53d5880e81915e9316" name="aef1b2e11225caa53d5880e81915e9316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1b2e11225caa53d5880e81915e9316">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespaceentt.html#a91aeaedca642d9e7220c77c7e1d2855b">is_meta_policy_v</a>&lt; Policy &gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to invoke a function given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00433">433</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="abe9a45bd7c93035354ec03dc7f196482" name="abe9a45bd7c93035354ec03dc7f196482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9a45bd7c93035354ec03dc7f196482">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceentt.html#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reset. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00617">617</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a4a0484b50821691e6aacea122481c1e6" name="a4a0484b50821691e6aacea122481c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0484b50821691e6aacea122481c1e6">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all meta types. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceentt.html#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00637">637</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="af9e4b586c541f816d71ff5c23b1d2a65" name="af9e4b586c541f816d71ff5c23b1d2a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e4b586c541f816d71ff5c23b1d2a65">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<p >Resets a type and all its data members, member functions and properties, as well as its constructors, destructors and conversion functions if any.<br  />
 Base classes aren't reset but the link between the two types is removed.</p>
<p >The type is also removed from the set of searchable types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00592">592</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a3d262b7705ff50f3fb58d2c90b2d6b61" name="a3d262b7705ff50f3fb58d2c90b2d6b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d262b7705ff50f3fb58d2c90b2d6b61">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceentt.html#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to reset meta types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00605">605</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a4671352f38341177295442a0d956c9d8" name="a4671352f38341177295442a0d956c9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4671352f38341177295442a0d956c9d8">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all meta types. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceentt.html#aa4a4a3ee0126a16959fcdfe6229fd057" title="Resets a type and all its parts.">meta_reset</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to reset meta types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00628">628</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="aa4a4a3ee0126a16959fcdfe6229fd057" name="aa4a4a3ee0126a16959fcdfe6229fd057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a4a3ee0126a16959fcdfe6229fd057">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<p >Resets a type and all its data members, member functions and properties, as well as its constructors, destructors and conversion functions if any.<br  />
 Base classes aren't reset but the link between the two types is removed.</p>
<p >The type is also removed from the set of searchable types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
    <tr><td class="paramname">ctx</td><td>The context from which to reset meta types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00569">569</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="ac14f35fbe2a40c6a94108b95507517fb" name="ac14f35fbe2a40c6a94108b95507517fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14f35fbe2a40c6a94108b95507517fb">&#9670;&nbsp;</a></span>meta_setter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::meta_setter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">value</td><td>Parameter to use to set the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00223">223</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ac0b95d19a5709187e6906a5a9c407b55" name="ac0b95d19a5709187e6906a5a9c407b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b95d19a5709187e6906a5a9c407b55">&#9670;&nbsp;</a></span>next_power_of_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::next_power_of_two </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest power of two greater than or equal to a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest power of two greater than or equal to the given value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00028">28</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a7c7a84015d46560a44cf751eed96cfeb" name="a7c7a84015d46560a44cf751eed96cfeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7a84015d46560a44cf751eed96cfeb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Scope of the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if both handles refer to the same registry and the same entity, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00376">376</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="ad9accc71a383509ada028f7fa2b767bf" name="ad9accc71a383509ada028f7fa2b767bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9accc71a383509ada028f7fa2b767bf">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00249">249</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ae663976796b773780f6136606c1a3f31" name="ae663976796b773780f6136606c1a3f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae663976796b773780f6136606c1a3f31">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two delegates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid delegate object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid delegate object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00293">293</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a0bfb4a52063118617d88ed10c9241cf1" name="a0bfb4a52063118617d88ed10c9241cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bfb4a52063118617d88ed10c9241cf1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00236">236</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a00032301649c088b76e496ba0d984ab0" name="a00032301649c088b76e496ba0d984ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00032301649c088b76e496ba0d984ab0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00315">315</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a883ee8e2a3f32a371b44e579ef0d0f25" name="a883ee8e2a3f32a371b44e579ef0d0f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883ee8e2a3f32a371b44e579ef0d0f25">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Value type of the iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A properly initialized iota iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>A properly initialized iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two iterators differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iterator_8hpp_source.html#l00131">131</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a id="a85b862c2db6e5771fb95d7a7930e9b18" name="a85b862c2db6e5771fb95d7a7930e9b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b862c2db6e5771fb95d7a7930e9b18">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two objects refer to the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>An object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>An object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the objects refer to the same node, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01489">1489</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="ab5abcbaafb983f804bef4fc83b58430e" name="ab5abcbaafb983f804bef4fc83b58430e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5abcbaafb983f804bef4fc83b58430e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Res</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if both handles refer to the same registry, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00186">186</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="afe4410448e22ae52de3bcbf262be9030" name="afe4410448e22ae52de3bcbf262be9030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4410448e22ae52de3bcbf262be9030">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two type info objects differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00198">198</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a6d5ebc5e9d0e87c18a22a72d2261bdf5" name="a6d5ebc5e9d0e87c18a22a72d2261bdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5ebc5e9d0e87c18a22a72d2261bdf5">&#9670;&nbsp;</a></span>operator&quot;&quot;_hs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">hashed_string</a> entt::literals::operator&quot;&quot;_hs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00317">317</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a6fa5b29e7184fb8fe184417411792290" name="a6fa5b29e7184fb8fe184417411792290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa5b29e7184fb8fe184417411792290">&#9670;&nbsp;</a></span>operator&quot;&quot;_hws()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">hashed_wstring</a> entt::literals::operator&quot;&quot;_hws </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed wstrings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed wstring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00326">326</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ab36ceb26049f62c07817a385e35395f6" name="ab36ceb26049f62c07817a385e35395f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36ceb26049f62c07817a385e35395f6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type..., Other... &gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple type lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Types provided by the first type list. </td></tr>
    <tr><td class="paramname">Other</td><td>Types provided by the second type list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type list composed by the types of both the type lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00209">209</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a722a64074f983c827563bdd5cf7d5dde" name="a722a64074f983c827563bdd5cf7d5dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722a64074f983c827563bdd5cf7d5dde">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... Value, auto... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value..., Other... &gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple value lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Values provided by the first value list. </td></tr>
    <tr><td class="paramname">Other</td><td>Values provided by the second value list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value list composed by the values of both the value lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00407">407</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aa88e297d57dd5547afcde8dd291c4b8f" name="aa88e297d57dd5547afcde8dd291c4b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88e297d57dd5547afcde8dd291c4b8f">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00261">261</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a6b29de0b43cc9ec62b8c0c194e3d9c44" name="a6b29de0b43cc9ec62b8c0c194e3d9c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b29de0b43cc9ec62b8c0c194e3d9c44">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Res</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00199">199</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="a5f6216409945594d3a50e9b8d3ad72f7" name="a5f6216409945594d3a50e9b8d3ad72f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6216409945594d3a50e9b8d3ad72f7">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00208">208</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a8c763e890bb00479a6a6aeae3b2a75f0" name="a8c763e890bb00479a6a6aeae3b2a75f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c763e890bb00479a6a6aeae3b2a75f0">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00274">274</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ae550c1310de77e009f6796229c67b1d7" name="ae550c1310de77e009f6796229c67b1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae550c1310de77e009f6796229c67b1d7">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Res</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00226">226</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="acce5a8a6786a787daa1a656f221158cf" name="acce5a8a6786a787daa1a656f221158cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce5a8a6786a787daa1a656f221158cf">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00219">219</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a3bf3030e5e15a6249460c9665395be79" name="a3bf3030e5e15a6249460c9665395be79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf3030e5e15a6249460c9665395be79">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Scope of the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both handles refer to the same registry and the same entity, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00362">362</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="af7c61951b721a1e3612cf536bd707501" name="af7c61951b721a1e3612cf536bd707501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c61951b721a1e3612cf536bd707501">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00237">237</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a6bd28fe24ca2b9544e78a296ce43ec2e" name="a6bd28fe24ca2b9544e78a296ce43ec2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd28fe24ca2b9544e78a296ce43ec2e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00224">224</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a067be6e3c78e4d6da28edce305773a0e" name="a067be6e3c78e4d6da28edce305773a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067be6e3c78e4d6da28edce305773a0e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00303">303</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a4423ccae6f6edef721acf6624b8cec41" name="a4423ccae6f6edef721acf6624b8cec41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4423ccae6f6edef721acf6624b8cec41">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1iota__iterator.html">iota_iterator</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Value type of the iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A properly initialized iota iterator. </td></tr>
    <tr><td class="paramname">rhs</td><td>A properly initialized iota iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two iterators are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="iterator_8hpp_source.html#l00119">119</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a id="a8673e2cd084833ef799c2b5e762d44d2" name="a8673e2cd084833ef799c2b5e762d44d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8673e2cd084833ef799c2b5e762d44d2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Res</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both handles refer to the same resource, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00173">173</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="a2dcf4803e990dfe0867025bf76de501c" name="a2dcf4803e990dfe0867025bf76de501c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcf4803e990dfe0867025bf76de501c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two type info objects are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00188">188</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="aec8131af000055ceab85646c14f234ad" name="aec8131af000055ceab85646c14f234ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8131af000055ceab85646c14f234ad">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00287">287</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a85c1f2e85a177861238ecc356f053f68" name="a85c1f2e85a177861238ecc356f053f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c1f2e85a177861238ecc356f053f68">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Res</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00212">212</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="abad8ef328173f0b43d96f8d042d7f444" name="abad8ef328173f0b43d96f8d042d7f444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8ef328173f0b43d96f8d042d7f444">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00230">230</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="adadb88dfb4278df554e7ffec5361ece4" name="adadb88dfb4278df554e7ffec5361ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadb88dfb4278df554e7ffec5361ece4">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00300">300</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a924a2fdb5e4c0c06546cda243b30d1e4" name="a924a2fdb5e4c0c06546cda243b30d1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924a2fdb5e4c0c06546cda243b30d1e4">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Res , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Res &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1resource.html">resource</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Res</td><td>Type of resource managed by the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of resource managed by the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first handle is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resource_8hpp_source.html#l00240">240</a> of file <a class="el" href="resource_8hpp_source.html">resource.hpp</a>.</p>

</div>
</div>
<a id="a502743d6a5b36ceff050779d93b444ca" name="a502743d6a5b36ceff050779d93b444ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502743d6a5b36ceff050779d93b444ca">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00241">241</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a267f6d6d3ea49bd36f7e8d2f002ec1d1" name="a267f6d6d3ea49bd36f7e8d2f002ec1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f6d6d3ea49bd36f7e8d2f002ec1d1">&#9670;&nbsp;</a></span>overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Func *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Function type of the desired overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A valid pointer to a function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00045">45</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ac5131df9ce458a6884c43595f501f916" name="ac5131df9ce458a6884c43595f501f916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5131df9ce458a6884c43595f501f916">&#9670;&nbsp;</a></span>overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Type Class::*&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded members of a class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the desired overload. </td></tr>
    <tr><td class="paramname">Class</td><td>Type of class to which the member belongs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>A valid pointer to a member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the member. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00034">34</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a26eb67ac302229374c5fb623d529f5eb" name="a26eb67ac302229374c5fb623d529f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eb67ac302229374c5fb623d529f5eb">&#9670;&nbsp;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1overloaded.html">entt::overloaded</a> </td>
          <td>(</td>
          <td class="paramtype">Func...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Types of function objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b4f2adf317a555138ef5c1cf45b034a" name="a8b4f2adf317a555138ef5c1cf45b034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f2adf317a555138ef5c1cf45b034a">&#9670;&nbsp;</a></span>poly_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Member, typename Poly , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::poly_call </td>
          <td>(</td>
          <td class="paramtype">Poly &amp;&amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;::invoke</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Index of the function to invoke. </td></tr>
    <tr><td class="paramname">Poly</td><td>A fully defined poly object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A reference to the poly object that made the call. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the invoked function, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="poly_8hpp_source.html#l00172">172</a> of file <a class="el" href="poly_8hpp_source.html">poly.hpp</a>.</p>

</div>
</div>
<a id="ae934980252d1f2ce8f2473c8d74347df" name="ae934980252d1f2ce8f2473c8d74347df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae934980252d1f2ce8f2473c8d74347df">&#9670;&nbsp;</a></span>propagate_on_container_copy_assignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void entt::propagate_on_container_copy_assignment </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00072">72</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a46cd263b358a2d495d4f4ee27d4537d7" name="a46cd263b358a2d495d4f4ee27d4537d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cd263b358a2d495d4f4ee27d4537d7">&#9670;&nbsp;</a></span>propagate_on_container_move_assignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void entt::propagate_on_container_move_assignment </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00085">85</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a0dd7ed3d3f11933cd542d8f4646cd695" name="a0dd7ed3d3f11933cd542d8f4646cd695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd7ed3d3f11933cd542d8f4646cd695">&#9670;&nbsp;</a></span>propagate_on_container_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void entt::propagate_on_container_swap </td>
          <td>(</td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00098">98</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a9dc2ece8ba5dafc463abdceb1f55eaea" name="a9dc2ece8ba5dafc463abdceb1f55eaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc2ece8ba5dafc463abdceb1f55eaea">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00032">32</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a1a1cf09707283197b9914fa8520e7592" name="a1a1cf09707283197b9914fa8520e7592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1cf09707283197b9914fa8520e7592">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceentt.html#a19a0f990ac8ad302430ef72224fb02eb">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt; entt::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range to use to visit all meta types. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterable range to use to visit all meta types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00050">50</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a4493a8ed8dc4bc71b11058973c0fd9aa" name="a4493a8ed8dc4bc71b11058973c0fd9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4493a8ed8dc4bc71b11058973c0fd9aa">&#9670;&nbsp;</a></span>resolve() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00075">75</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="ad86fb3538f9ba64b4695cf45c020458e" name="ad86fb3538f9ba64b4695cf45c020458e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86fb3538f9ba64b4695cf45c020458e">&#9670;&nbsp;</a></span>resolve() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00021">21</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a894939ee94a38b6843a8d29ab770f36a" name="a894939ee94a38b6843a8d29ab770f36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894939ee94a38b6843a8d29ab770f36a">&#9670;&nbsp;</a></span>resolve() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceentt.html#a19a0f990ac8ad302430ef72224fb02eb">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a>, typename decltype(internal::meta_context::value)::const_iterator &gt; entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range to use to visit all meta types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterable range to use to visit all meta types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00041">41</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a669729b83f4e0e2433cbf2a881745e22" name="a669729b83f4e0e2433cbf2a881745e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669729b83f4e0e2433cbf2a881745e22">&#9670;&nbsp;</a></span>resolve() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00060">60</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a7072f59c8738e44792806ab65c693032" name="a7072f59c8738e44792806ab65c693032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7072f59c8738e44792806ab65c693032">&#9670;&nbsp;</a></span>resolve() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__ctx.html">meta_ctx</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type info object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context from which to search for meta types. </td></tr>
    <tr><td class="paramname">info</td><td>The type info object of the requested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type info object, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00085">85</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a28dcce4d98f6a27c4c61e814466900b2" name="a28dcce4d98f6a27c4c61e814466900b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dcce4d98f6a27c4c61e814466900b2">&#9670;&nbsp;</a></span>resolve() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type info object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The type info object of the requested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type info object, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00096">96</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="aebd935c76f0b7bf40958ec43565ea157" name="aebd935c76f0b7bf40958ec43565ea157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd935c76f0b7bf40958ec43565ea157">&#9670;&nbsp;</a></span>sink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args, typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sink.html">entt::sink</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1sink.html">sink</a>&lt; <a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p >It allows to deduce the signal handler type of a sink directly from the signal it refers to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85aff290a542f0f053b993b507410b21" name="a85aff290a542f0f053b993b507410b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85aff290a542f0f053b993b507410b21">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void entt::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two compressed pair objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">First</td><td>The type of the first element that the pairs store. </td></tr>
    <tr><td class="paramname">Second</td><td>The type of the second element that the pairs store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid compressed pair object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid compressed pair object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="compressed__pair_8hpp_source.html#l00247">247</a> of file <a class="el" href="compressed__pair_8hpp_source.html">compressed_pair.hpp</a>.</p>

</div>
</div>
<a id="af0ecb90b45a53e3272d761c237a0d850" name="af0ecb90b45a53e3272d761c237a0d850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ecb90b45a53e3272d761c237a0d850">&#9670;&nbsp;</a></span>to_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::to_address </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unwraps fancy pointers, does nothing otherwise (waiting for C++20). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Fancy or raw pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer that represents the address of the original pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00057">57</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a1202b4027d32db124efffdf1f2f8c5a2" name="a1202b4027d32db124efffdf1f2f8c5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202b4027d32db124efffdf1f2f8c5a2">&#9670;&nbsp;</a></span>to_entity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity part once converted to the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the entity part. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00148">148</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="adafe8aa84438fa3781ebd05fb93ddef4" name="adafe8aa84438fa3781ebd05fb93ddef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafe8aa84438fa3781ebd05fb93ddef4">&#9670;&nbsp;</a></span>to_entity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Registry , typename Component &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Registry::entity_type entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const Registry &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Component &amp;&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the entity associated with a given component. </p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this function only works correctly with the default pool as it makes assumptions about how the components are laid out.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Registry</td><td>Basic registry type. </td></tr>
    <tr><td class="paramname">Component</td><td>Type of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">instance</td><td>A valid component instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity associated with the given component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00128">128</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="ad2e252dbd8c8ebd486a3d84fbf8c2602" name="ad2e252dbd8c8ebd486a3d84fbf8c2602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e252dbd8c8ebd486a3d84fbf8c2602">&#9670;&nbsp;</a></span>to_integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type entt::to_integral </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an entity to its underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the given value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00139">139</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a4b7d8995ec3448ce5151309ef2281d33" name="a4b7d8995ec3448ce5151309ef2281d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7d8995ec3448ce5151309ef2281d33">&#9670;&nbsp;</a></span>to_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::version_type entt::to_version </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version part once converted to the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the version part. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00157">157</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="adb9682d476edbbe4434680363f9c0eb3" name="adb9682d476edbbe4434680363f9c0eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9682d476edbbe4434680363f9c0eb3">&#9670;&nbsp;</a></span>type_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp; entt::type_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type info object associated to a given type. </p>
<p >The returned element refers to an object with static storage duration.<br  />
 The type doesn't need to be a complete type. If the type is a reference, the result refers to the referenced type. In all cases, top-level cv-qualifiers are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type for which to generate a type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to a properly initialized type info object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00257">257</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a17387091b8374f89bfd73b2630768b53" name="a17387091b8374f89bfd73b2630768b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17387091b8374f89bfd73b2630768b53">&#9670;&nbsp;</a></span>type_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp; entt::type_id </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type info object associated to a given type. </p>
<p >The returned element refers to an object with static storage duration.<br  />
 The type doesn't need to be a complete type. If the type is a reference, the result refers to the referenced type. In all cases, top-level cv-qualifiers are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type for which to generate a type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to a properly initialized type info object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00268">268</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a81f946567d220e7c8814636333d0cbe0" name="a81f946567d220e7c8814636333d0cbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f946567d220e7c8814636333d0cbe0">&#9670;&nbsp;</a></span>uninitialized_construct_using_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Allocator , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Type * entt::uninitialized_construct_using_allocator </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses-allocator construction utility (waiting for C++20). </p>
<p >Primarily intended for internal use. Creates an object of a given type by means of uses-allocator construction at an uninitialized memory location.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to create. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Memory location in which to place the object. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00283">283</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="abf2665e41871f7493f674c8dbba0a593" name="abf2665e41871f7493f674c8dbba0a593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2665e41871f7493f674c8dbba0a593">&#9670;&nbsp;</a></span>unwrap_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) entt::unwrap_tuple </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to unwrap tuples of a single element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Tuple type of any sizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A tuple object of the given type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tuple itself if it contains more than one element, the first element otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00053">53</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ac447ddab9d528647a79fd9aca429faed" name="ac447ddab9d528647a79fd9aca429faed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac447ddab9d528647a79fd9aca429faed">&#9670;&nbsp;</a></span>uses_allocator_construction_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Allocator , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::uses_allocator_construction_args </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses-allocator construction utility (waiting for C++20). </p>
<p >Primarily intended for internal use. Prepares the argument list needed to create an object of a given type by means of uses-allocator construction.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to return arguments for. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to construct the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arguments needed to create an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00246">246</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a089f75043b082abca3ea144bce44e9ae" name="a089f75043b082abca3ea144bce44e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f75043b082abca3ea144bce44e9ae">&#9670;&nbsp;</a></span>choice</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt;N&gt; entt::choice {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for the choice trick. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of choices available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00032">32</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aea8b073b774362fe800d9cce3542927a" name="aea8b073b774362fe800d9cce3542927a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8b073b774362fe800d9cce3542927a">&#9670;&nbsp;</a></span>collector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1basic__collector.html">basic_collector</a> entt::collector {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template used to ease the definition of collectors. </p>

<p class="definition">Definition at line <a class="el" href="observer_8hpp_source.html#l00109">109</a> of file <a class="el" href="observer_8hpp_source.html">observer.hpp</a>.</p>

</div>
</div>
<a id="a142bebb2be3b87a778b1932b3a267a57" name="a142bebb2be3b87a778b1932b3a267a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142bebb2be3b87a778b1932b3a267a57">&#9670;&nbsp;</a></span>connect_arg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt;Candidate&gt; entt::connect_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Disambiguation tag for constructors and the like.">connect_arg_t</a> used to disambiguate calls. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Element to connect (likely a free or member function). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="signal_2fwd_8hpp_source.html#l00042">42</a> of file <a class="el" href="signal_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a8378b9330b5c90b6b11deee3637ebca6" name="a8378b9330b5c90b6b11deee3637ebca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8378b9330b5c90b6b11deee3637ebca6">&#9670;&nbsp;</a></span>enum_as_bitmask_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::enum_as_bitmask_v = <a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The enum class type for which to enable bitmask support. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="enum_8hpp_source.html#l00024">24</a> of file <a class="el" href="enum_8hpp_source.html">enum.hpp</a>.</p>

</div>
</div>
<a id="a5b73210cef43c4db35ef8ce477cc38a6" name="a5b73210cef43c4db35ef8ce477cc38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73210cef43c4db35ef8ce477cc38a6">&#9670;&nbsp;</a></span>exclude</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#a806da7d3930a8e5fff66e8f4be841f44">exclude_t</a>&lt;Type...&gt; entt::exclude {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for exclusion lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00071">71</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a8c24ecc5ab0055f9f2a4725c95afb29e" name="a8c24ecc5ab0055f9f2a4725c95afb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c24ecc5ab0055f9f2a4725c95afb29e">&#9670;&nbsp;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#a0848971d27a69686665fb953fc62f4df">get_t</a>&lt;Type...&gt; entt::get {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of observed components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00085">85</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="ab9f9b531ebde614244a0da111d4b66ff" name="ab9f9b531ebde614244a0da111d4b66ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f9b531ebde614244a0da111d4b66ff">&#9670;&nbsp;</a></span>ignore_as_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::ignore_as_empty_v = (std::is_void_v&lt;Type&gt; || <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt;Type&gt;::page_size == 0u)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of component. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="component_8hpp_source.html#l00060">60</a> of file <a class="el" href="component_8hpp_source.html">component.hpp</a>.</p>

</div>
</div>
<a id="ae764716fab8c01b12d3e209004b62647" name="ae764716fab8c01b12d3e209004b62647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae764716fab8c01b12d3e209004b62647">&#9670;&nbsp;</a></span>is_applicable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_applicable_r_v = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>The type to which the return type of the function should be convertible. </td></tr>
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00503">503</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4f238620469de3ef2bafdb28fe4657ef" name="a4f238620469de3ef2bafdb28fe4657ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f238620469de3ef2bafdb28fe4657ef">&#9670;&nbsp;</a></span>is_applicable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_applicable_v = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00479">479</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a8a96fcc4bc8da9a2aa1cdb0bc15b75c8" name="a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">&#9670;&nbsp;</a></span>is_complete_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_complete_v = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00522">522</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="afb5b1446d23f1cba20563114f5da1f9d" name="afb5b1446d23f1cba20563114f5da1f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5b1446d23f1cba20563114f5da1f9d">&#9670;&nbsp;</a></span>is_ebco_eligible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_ebco_eligible_v = <a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00578">578</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a068dd98a70c771935d2bf3dd96dbad6d" name="a068dd98a70c771935d2bf3dd96dbad6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068dd98a70c771935d2bf3dd96dbad6d">&#9670;&nbsp;</a></span>is_equality_comparable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_equality_comparable_v = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00667">667</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3ac133ddb24ec535a11baf3143d188d6" name="a3ac133ddb24ec535a11baf3143d188d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac133ddb24ec535a11baf3143d188d6">&#9670;&nbsp;</a></span>is_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_iterator_v = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00562">562</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aaa8c390cfe71301a0c10f4844e98424c" name="aaa8c390cfe71301a0c10f4844e98424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8c390cfe71301a0c10f4844e98424c">&#9670;&nbsp;</a></span>is_meta_pointer_like_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_meta_pointer_like_v = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially pointer-like type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2type__traits_8hpp_source.html#l00051">51</a> of file <a class="el" href="meta_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a91aeaedca642d9e7220c77c7e1d2855b" name="a91aeaedca642d9e7220c77c7e1d2855b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aeaedca642d9e7220c77c7e1d2855b">&#9670;&nbsp;</a></span>is_meta_policy_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_meta_policy_v = <a class="el" href="structentt_1_1is__meta__policy.html">is_meta_policy</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to check. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="policy_8hpp_source.html#l00082">82</a> of file <a class="el" href="policy_8hpp_source.html">policy.hpp</a>.</p>

</div>
</div>
<a id="a5fd3998d86cc531f800d0104478771f4" name="a5fd3998d86cc531f800d0104478771f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd3998d86cc531f800d0104478771f4">&#9670;&nbsp;</a></span>is_transparent_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_transparent_v = <a class="el" href="structentt_1_1is__transparent.html">is_transparent</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00597">597</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a0617c69b8aa01b123162d23d7213c6aa" name="a0617c69b8aa01b123162d23d7213c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0617c69b8aa01b123162d23d7213c6aa">&#9670;&nbsp;</a></span>is_tuple_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_tuple_v = <a class="el" href="structentt_1_1is__tuple.html">is_tuple</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00043">43</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="aa7148c0f5c0a81e2c48c9d4e52d31f55" name="aa7148c0f5c0a81e2c48c9d4e52d31f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7148c0f5c0a81e2c48c9d4e52d31f55">&#9670;&nbsp;</a></span>meta_ctx_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1meta__ctx__arg__t.html">meta_ctx_arg_t</a> entt::meta_ctx_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant of type meta_context_arg_t used to disambiguate calls. </p>

<p class="definition">Definition at line <a class="el" href="context_8hpp_source.html#l00039">39</a> of file <a class="el" href="context_8hpp_source.html">context.hpp</a>.</p>

</div>
</div>
<a id="ab43a13f7ee60bcb0d04a001f92b86fa2" name="ab43a13f7ee60bcb0d04a001f92b86fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43a13f7ee60bcb0d04a001f92b86fa2">&#9670;&nbsp;</a></span>monostate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> Value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt;Value&gt; entt::monostate_v = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Value used to differentiate between different variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="monostate_8hpp_source.html#l00052">52</a> of file <a class="el" href="monostate_8hpp_source.html">monostate.hpp</a>.</p>

</div>
</div>
<a id="a2f0c0a1c1d953ea991591748744cdd8b" name="a2f0c0a1c1d953ea991591748744cdd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c0a1c1d953ea991591748744cdd8b">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a> entt::null {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for null entities. </p>
<p >There exist implicit conversions from this variable to identifiers of any allowed type. Similarly, there exist comparison operators between the null entity and any other identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00326">326</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="ac91ddbe2446a912714a5fe7251e25768" name="ac91ddbe2446a912714a5fe7251e25768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91ddbe2446a912714a5fe7251e25768">&#9670;&nbsp;</a></span>owned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#a68dd3ca7c921555e1635fde386d9b243">owned_t</a>&lt;Type...&gt; entt::owned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of owned components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00099">99</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a15f9a70cbdd5a64f897a012ab2b5834f" name="a15f9a70cbdd5a64f897a012ab2b5834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f9a70cbdd5a64f897a012ab2b5834f">&#9670;&nbsp;</a></span>size_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::size_of_v = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of which to return the size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00073">73</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a674269102fdfe3fd6d7766210a828862" name="a674269102fdfe3fd6d7766210a828862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674269102fdfe3fd6d7766210a828862">&#9670;&nbsp;</a></span>tombstone</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> entt::tombstone {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for tombstone entities. </p>
<p >There exist implicit conversions from this variable to identifiers of any allowed type. Similarly, there exist comparison operators between the tombstone entity and any other identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00335">335</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a988ce063936d499bf2d69406c391fd5c" name="a988ce063936d499bf2d69406c391fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ce063936d499bf2d69406c391fd5c">&#9670;&nbsp;</a></span>type_list_contains_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::type_list_contains_v = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Type</td><td>Type to look for. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00308">308</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3a9e46d106b526d281a35901da1edea6" name="a3a9e46d106b526d281a35901da1edea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9e46d106b526d281a35901da1edea6">&#9670;&nbsp;</a></span>type_list_index_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::type_list_index_v = <a class="el" href="structentt_1_1type__list__index.html">type_list_index</a>&lt;Type, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Type</td><td>Type to look for and for which to return the index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00200">200</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aee7558c4e09ee416fb7fa3576737ff65" name="aee7558c4e09ee416fb7fa3576737ff65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7558c4e09ee416fb7fa3576737ff65">&#9670;&nbsp;</a></span>unpack_as_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value, typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::unpack_as_value = Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A value to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00089">89</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4bbfb162708696f9c1497d61573b540f" name="a4bbfb162708696f9c1497d61573b540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfb162708696f9c1497d61573b540f">&#9670;&nbsp;</a></span>value_list_element_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::value_list_element_v = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the value to return. </td></tr>
    <tr><td class="paramname">List</td><td>Value list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00398">398</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
