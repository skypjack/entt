EXAMPLES
* filter on runtime values/variables (not only types)
* support to polymorphic types (see #859)

DOC:
* custom storage/view
* update entity doc when the storage based model is in place
* in-place O(1) release/destroy for non-orphaned entities, out-of-sync model
* view: single vs multi type views are no longer a thing actually
* bump entities, reserved bits on identifiers

TODO:
* review all NOLINT
* bring nested groups back in place (see bd34e7f)
* work stealing job system (see #100) + mt scheduler based on const awareness for types
* combine version-mask-vs-version-bits tricks with reserved bits to allow things like enabling/disabling
* self contained entity traits to avoid explicit specializations (ie enum constants)
* auto type info data from types if present
* storage entity: fast range-push from above
* table: pop back to support swap and pop, single column access, empty type optimization
* suppress -Wself-move on CI with g++13
* runtime types support for meta for types that aren't backed by C++ types
* built-in no-pagination storage - no_pagination page size as limits::max
* any cdynamic to support const ownership construction
* allow passing arguments to meta setter/getter (we can fallback on meta invoke probably)
* meta non-const allow_cast overloads: (const int &) to (int &) is not allowed, but (const int &) to (double &) is allowed (support only for convertibles)
* review build process for testbed (i.e. tests first due to SDL)
* use unique_ptr or any for meta_custom_node
* paged vector as a standalone class
* resource: shared_from_this?
* finish the imgui viewer/editor!
* archetype-like a-là EnTT support (see my own notes)
* meta: conversion_helper machinery has lot of room for improvements
* organizer: view/storage only based model, no registry
* introduce a way to inject stl from outside too
* redesign snapshot as a whole
* storage: trivial destructor on exit (ie shrink_to_size) and clear/pop_all
* use the value type mixin more in the test suite to reduce the number of utility types
* explore "runtime" mode for hashed string where the source is copied internally
* swap_only/swap_and_pop/in_place_pop can (should?) accept the entity
* we can likely improve storage::pop for trivially destructible non in_place_delete types
* test trivially_destructible optimization
